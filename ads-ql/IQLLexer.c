/** \file
 *  This C source file was generated by $ANTLR version 3.2 Sep 23, 2009 12:02:23
 *
 *     -  From the grammar source file : IQL.g
 *     -                            On : 2012-01-31 17:12:39
 *     -                 for the lexer : IQLLexerLexer *
 * Editing it, at least manually, is not wise. 
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/
// [The "BSD licence"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "IQLLexer.h"
/* ----------------------------------------- */


/** String literals used by IQLLexer that we must do things like MATCHS() with.
 *  C will normally just lay down 8 bit characters, and you can use L"xxx" to
 *  get wchar_t, but wchar_t is 16 bits on Windows, which is not UTF32 and so
 *  we perform this little trick of defining the literals as arrays of UINT32
 *  and passing in the address of these.
 */
static ANTLR3_UCHAR	lit_1[]  = { 0x2D, 0x3E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_2[]  = { 0x3E, 0x3D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_3[]  = { 0x3C, 0x3D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_4[]  = { 0x3C, 0x3E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_5[]  = { 0x41, 0x44, 0x44,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_6[]  = { 0x41, 0x4C, 0x4C,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_7[]  = { 0x41, 0x4C, 0x54, 0x45, 0x52,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_8[]  = { 0x41, 0x4E, 0x44,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_9[]  = { 0x41, 0x4E, 0x59,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_10[]  = { 0x41, 0x53,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_11[]  = { 0x41, 0x53, 0x43,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_12[]  = { 0x41, 0x56, 0x47,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_13[]  = { 0x42, 0x45, 0x47, 0x49, 0x4E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_14[]  = { 0x42, 0x45, 0x54, 0x57, 0x45, 0x45, 0x4E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_15[]  = { 0x42, 0x49, 0x47, 0x49, 0x4E, 0x54,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_16[]  = { 0x42, 0x4F, 0x4F, 0x4C, 0x45, 0x41, 0x4E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_17[]  = { 0x42, 0x52, 0x45, 0x41, 0x4B,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_18[]  = { 0x42, 0x59,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_19[]  = { 0x43, 0x41, 0x53, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_20[]  = { 0x43, 0x41, 0x53, 0x54,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_21[]  = { 0x43, 0x48, 0x41, 0x52,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_22[]  = { 0x43, 0x4F, 0x41, 0x4C, 0x45, 0x53, 0x43, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_23[]  = { 0x43, 0x4F, 0x4E, 0x54, 0x49, 0x4E, 0x55, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_24[]  = { 0x43, 0x4F, 0x55, 0x4E, 0x54,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_25[]  = { 0x43, 0x52, 0x45, 0x41, 0x54, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_26[]  = { 0x43, 0x52, 0x4F, 0x53, 0x53,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_27[]  = { 0x44, 0x41, 0x54, 0x45, 0x54, 0x49, 0x4D, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_28[]  = { 0x44, 0x45, 0x43, 0x4C, 0x41, 0x52, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_29[]  = { 0x44, 0x45, 0x43, 0x49, 0x4D, 0x41, 0x4C,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_30[]  = { 0x44, 0x45, 0x53, 0x43,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_31[]  = { 0x44, 0x49, 0x53, 0x54, 0x49, 0x4E, 0x43, 0x54,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_32[]  = { 0x44, 0x4F, 0x55, 0x42, 0x4C, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_33[]  = { 0x45, 0x4C, 0x53, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_34[]  = { 0x45, 0x4E, 0x44,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_35[]  = { 0x45, 0x58, 0x49, 0x53, 0x54, 0x53,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_36[]  = { 0x46, 0x41, 0x4C, 0x53, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_37[]  = { 0x46, 0x52, 0x4F, 0x4D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_38[]  = { 0x46, 0x55, 0x4C, 0x4C,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_39[]  = { 0x46, 0x55, 0x4E, 0x43, 0x54, 0x49, 0x4F, 0x4E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_40[]  = { 0x47, 0x52, 0x4F, 0x55, 0x50,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_41[]  = { 0x48, 0x41, 0x56, 0x49, 0x4E, 0x47,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_42[]  = { 0x49, 0x46,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_43[]  = { 0x49, 0x4E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_44[]  = { 0x49, 0x4E, 0x44, 0x45, 0x58,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_45[]  = { 0x49, 0x4E, 0x4E, 0x45, 0x52,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_46[]  = { 0x49, 0x4E, 0x54, 0x4F,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_47[]  = { 0x49, 0x4E, 0x54, 0x45, 0x47, 0x45, 0x52,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_48[]  = { 0x49, 0x4E, 0x54, 0x45, 0x52, 0x56, 0x41, 0x4C,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_49[]  = { 0x49, 0x53,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_50[]  = { 0x4A, 0x4F, 0x49, 0x4E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_51[]  = { 0x4B, 0x45, 0x59,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_52[]  = { 0x4C, 0x45, 0x46, 0x54,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_53[]  = { 0x4C, 0x49, 0x4B, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_54[]  = { 0x4D, 0x41, 0x58,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_55[]  = { 0x4D, 0x49, 0x4E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_56[]  = { 0x4E, 0x4F, 0x54,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_57[]  = { 0x4E, 0x55, 0x4C, 0x4C,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_58[]  = { 0x4E, 0x56, 0x41, 0x52, 0x43, 0x48, 0x41, 0x52,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_59[]  = { 0x4F, 0x4E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_60[]  = { 0x4F, 0x52,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_61[]  = { 0x4F, 0x52, 0x44, 0x45, 0x52,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_62[]  = { 0x4F, 0x55, 0x54, 0x45, 0x52,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_63[]  = { 0x4F, 0x55, 0x54, 0x50, 0x55, 0x54,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_64[]  = { 0x50, 0x52, 0x45, 0x43, 0x49, 0x53, 0x49, 0x4F, 0x4E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_65[]  = { 0x50, 0x52, 0x49, 0x4E, 0x54,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_66[]  = { 0x50, 0x52, 0x4F, 0x43, 0x45, 0x44, 0x55, 0x52, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_67[]  = { 0x52, 0x41, 0x49, 0x53, 0x45, 0x52, 0x52, 0x4F, 0x52,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_68[]  = { 0x52, 0x45, 0x54, 0x55, 0x52, 0x4E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_69[]  = { 0x52, 0x45, 0x54, 0x55, 0x52, 0x4E, 0x53,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_70[]  = { 0x52, 0x49, 0x47, 0x48, 0x54,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_71[]  = { 0x52, 0x4C, 0x49, 0x4B, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_72[]  = { 0x53, 0x45, 0x4C, 0x45, 0x43, 0x54,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_73[]  = { 0x53, 0x45, 0x54,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_74[]  = { 0x53, 0x4F, 0x4D, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_75[]  = { 0x53, 0x55, 0x4D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_76[]  = { 0x53, 0x57, 0x49, 0x54, 0x43, 0x48,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_77[]  = { 0x54, 0x48, 0x45, 0x4E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_78[]  = { 0x54, 0x52, 0x55, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_79[]  = { 0x55, 0x4E, 0x49, 0x4F, 0x4E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_80[]  = { 0x56, 0x41, 0x52, 0x43, 0x48, 0x41, 0x52,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_81[]  = { 0x57, 0x48, 0x45, 0x4E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_82[]  = { 0x57, 0x48, 0x45, 0x52, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_83[]  = { 0x57, 0x48, 0x49, 0x4C, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_84[]  = { 0x57, 0x49, 0x54, 0x48,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_85[]  = { 0x4E, 0x27,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_86[]  = { 0x2F, 0x2A,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_87[]  = { 0x2A, 0x2F,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_88[]  = { 0x2F, 0x2F,  ANTLR3_STRING_TERMINATOR};




/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */
 
#define		CTX	ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   pIQLLexer_##scope##_SCOPE
#define SCOPE_STACK(scope)  pIQLLexer_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->pIQLLexer_##scope##Top
#define	SCOPE_SIZE(scope)		ctx->pIQLLexer_##scope##Stack_limit
#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))

 
/* Macros for accessing things in a lexer
 */
#undef	    LEXER
#undef	    RECOGNIZER		    
#undef	    RULEMEMO		    
#undef	    GETCHARINDEX
#undef	    GETLINE
#undef	    GETCHARPOSITIONINLINE
#undef	    EMIT
#undef	    EMITNEW
#undef	    MATCHC
#undef	    MATCHS
#undef	    MATCHRANGE
#undef	    LTOKEN
#undef	    HASFAILED
#undef	    FAILEDFLAG
#undef	    INPUT
#undef	    STRSTREAM
#undef	    LA
#undef	    HASEXCEPTION
#undef	    EXCEPTION
#undef	    CONSTRUCTEX
#undef	    CONSUME
#undef	    LRECOVER
#undef	    MARK
#undef	    REWIND
#undef	    REWINDLAST
#undef	    BACKTRACKING
#undef		MATCHANY
#undef		MEMOIZE
#undef		HAVEPARSEDRULE
#undef		GETTEXT
#undef		INDEX
#undef		SEEK
#undef		PUSHSTREAM
#undef		POPSTREAM
#undef		SETTEXT
#undef		SETTEXT8

#define	    LEXER					ctx->pLexer
#define	    RECOGNIZER			    LEXER->rec
#define		LEXSTATE				RECOGNIZER->state
#define		TOKSOURCE				LEXSTATE->tokSource
#define	    GETCHARINDEX()			LEXER->getCharIndex(LEXER)
#define	    GETLINE()				LEXER->getLine(LEXER)
#define	    GETTEXT()				LEXER->getText(LEXER)
#define	    GETCHARPOSITIONINLINE() LEXER->getCharPositionInLine(LEXER)
#define	    EMIT()					LEXSTATE->type = _type; LEXER->emit(LEXER)
#define	    EMITNEW(t)				LEXER->emitNew(LEXER, t)
#define	    MATCHC(c)				LEXER->matchc(LEXER, c)
#define	    MATCHS(s)				LEXER->matchs(LEXER, s)
#define	    MATCHRANGE(c1,c2)	    LEXER->matchRange(LEXER, c1, c2)
#define	    MATCHANY()				LEXER->matchAny(LEXER)
#define	    LTOKEN  				LEXSTATE->token
#define	    HASFAILED()				(LEXSTATE->failed == ANTLR3_TRUE)
#define	    BACKTRACKING			LEXSTATE->backtracking
#define	    FAILEDFLAG				LEXSTATE->failed
#define	    INPUT					LEXER->input
#define	    STRSTREAM				INPUT
#define		ISTREAM					INPUT->istream
#define		INDEX()					ISTREAM->index(ISTREAM)
#define		SEEK(n)					ISTREAM->seek(ISTREAM, n)
#define	    EOF_TOKEN				&(LEXSTATE->tokSource->eofToken)
#define	    HASEXCEPTION()			(LEXSTATE->error == ANTLR3_TRUE)
#define	    EXCEPTION				LEXSTATE->exception
#define	    CONSTRUCTEX()			RECOGNIZER->exConstruct(RECOGNIZER)
#define	    LRECOVER()				LEXER->recover(LEXER)
#define	    MARK()					ISTREAM->mark(ISTREAM)
#define	    REWIND(m)				ISTREAM->rewind(ISTREAM, m)
#define	    REWINDLAST()			ISTREAM->rewindLast(ISTREAM)
#define		MEMOIZE(ri,si)			RECOGNIZER->memoize(RECOGNIZER, ri, si)
#define		HAVEPARSEDRULE(r)		RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define		PUSHSTREAM(str)			LEXER->pushCharStream(LEXER, str)
#define		POPSTREAM()				LEXER->popCharStream(LEXER)
#define		SETTEXT(str)			LEXSTATE->text = str
#define		SKIP()					LEXSTATE->token = &(TOKSOURCE->skipToken)
#define		USER1					LEXSTATE->user1
#define		USER2					LEXSTATE->user2
#define		USER3					LEXSTATE->user3
#define		CUSTOM					LEXSTATE->custom
#define		RULEMEMO				LEXSTATE->ruleMemo
#define		DBG						RECOGNIZER->debugger

/* If we have been told we can rely on the standard 8 bit or 16 bit input
 * stream, then we can define our macros to use the direct pointers
 * in the input object, which is much faster than indirect calls. This
 * is really only significant to lexers with a lot of fragment rules (which
 * do not place LA(1) in a temporary at the moment) and even then
 * only if there is a lot of input (order of say 1M or so).
 */
#if	defined(ANTLR3_INLINE_INPUT_ASCII) || defined(ANTLR3_INLINE_INPUT_UTF16)

# ifdef	ANTLR3_INLINE_INPUT_ASCII

/* 8 bit "ASCII" (actually any 8 bit character set) */

#  define	    NEXTCHAR			((pANTLR3_UINT8)(INPUT->nextChar))
#  define	    DATAP				((pANTLR3_UINT8)(INPUT->data))

# else

#  define	    NEXTCHAR			((pANTLR3_UINT16)(INPUT->nextChar)) 
#  define	    DATAP				((pANTLR3_UINT16)(INPUT->data))

# endif

# define	    LA(n) ((NEXTCHAR + n) > (DATAP + INPUT->sizeBuf) ? ANTLR3_CHARSTREAM_EOF : (ANTLR3_UCHAR)(*(NEXTCHAR + n - 1)))
# define	    CONSUME()											\
{																	\
    if	(NEXTCHAR < (DATAP + INPUT->sizeBuf))						\
    {																\
		INPUT->charPositionInLine++;								\
		if  ((ANTLR3_UCHAR)(*NEXTCHAR) == INPUT->newlineChar)		\
		{															\
			INPUT->line++;											\
			INPUT->charPositionInLine	= 0;						\
			INPUT->currentLine		= (void *)(NEXTCHAR + 1);		\
		}															\
		INPUT->nextChar = (void *)(NEXTCHAR + 1);					\
    }																\
}

#else

// Pick up the input character by calling the input stream implementation.
//
#define	    CONSUME()				INPUT->istream->consume(INPUT->istream)
#define	    LA(n)					INPUT->istream->_LA(INPUT->istream, n)

#endif
#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define	    UP	    ANTLR3_TOKEN_UP
#define	    DOWN    ANTLR3_TOKEN_DOWN
#define	    EOR	    ANTLR3_TOKEN_EOR
#define	    INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */



/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */


/* Forward declare the locally static matching functions we have generated and any predicate functions.
 */
static ANTLR3_INLINE  void	mT__107    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__108    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__109    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__110    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__111    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__112    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__113    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__114    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__115    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__116    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__117    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__118    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__119    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__120    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__121    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__122    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__123    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__124    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__125    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__126    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__127    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__128    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__129    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__130    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__131    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__132    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mT__133    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_ADD    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_ALL    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_ALTER    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_AND    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_ANY    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_AS    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_ASC    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_AVG    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_BEGIN    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_BETWEEN    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_BIGINT    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_BOOLEAN    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_BREAK    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_BY    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_CASE    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_CAST    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_CHAR    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_COALESCE    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_CONTINUE    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_COUNT    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_CREATE    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_CROSS    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_DATETIME    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_DECLARE    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_DECIMAL    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_DESC    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_DISTINCT    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_DOUBLE    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_ELSE    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_END    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_EXISTS    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_FALSE    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_FROM    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_FULL    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_FUNCTION    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_GROUP    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_HAVING    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_IF    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_IN    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_INDEX    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_INNER    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_INTO    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_INTEGER    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_INTERVAL    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_IS    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_JOIN    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_KEY    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_LEFT    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_LIKE    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_MAX    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_MIN    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_NOT    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_NULL    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_NVARCHAR    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_ON    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_OR    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_ORDER    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_OUTER    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_OUTPUT    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_PRECISION    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_PRINT    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_PROCEDURE    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_RAISERROR    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_RETURN    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_RETURNS    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_RIGHT    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_RLIKE    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_SELECT    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_SET    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_SOME    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_SUM    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_SWITCH    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_THEN    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_TRUE    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_UNION    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_VARCHAR    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_WHEN    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_WHERE    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_WHILE    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTK_WITH    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mSTRING_LITERAL    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mWSTRING_LITERAL    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mDOUBLE_QUOTED_STRING_LITERAL    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mESCAPE_SEQUENCE    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mOCTAL_ESCAPE    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mHEX_DIGIT    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mUNICODE_ESCAPE    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mWS    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mML_COMMENT    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mSL_COMMENT    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mID    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mQUOTED_ID    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mBIGINT_SUFFIX    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mHEX_INTEGER_LITERAL    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mDECIMAL_INTEGER_LITERAL    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mDECIMAL_BIGINT_LITERAL    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mFLOATING_POINT_LITERAL    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mEXPONENT    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mFLOAT_SUFFIX    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mDECIMAL_LITERAL    (pIQLLexer ctx);
static ANTLR3_INLINE  void	mTokens    (pIQLLexer ctx);
static void	IQLLexerFree(pIQLLexer ctx);

/* =========================================================================
 * Lexer matching rules end.
 * =========================================================================
 */



static void
IQLLexerFree  (pIQLLexer ctx)
{
    LEXER->free(LEXER);
    
    ANTLR3_FREE(ctx);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "IQL.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
	return fileName;
}

/** \brief Create a new lexer called IQLLexer
 *
 * \param[in]    instream Pointer to an initialized input stream
 * \return 
 *     - Success pIQLLexer initialized for the lex start
 *     - Fail NULL
 */
ANTLR3_API pIQLLexer IQLLexerNew         
(pANTLR3_INPUT_STREAM instream)
{
	// See if we can create a new lexer with the standard constructor
	//
	return IQLLexerNewSSD(instream, NULL);
}

/** \brief Create a new lexer called IQLLexer
 *
 * \param[in]    instream Pointer to an initialized input stream
 * \param[state] state Previously created shared recognizer stat
 * \return 
 *     - Success pIQLLexer initialized for the lex start
 *     - Fail NULL
 */
ANTLR3_API pIQLLexer IQLLexerNewSSD         
(pANTLR3_INPUT_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    pIQLLexer ctx; // Context structure we will build and return

    ctx = (pIQLLexer) ANTLR3_CALLOC(1, sizeof(IQLLexer));

    if  (ctx == NULL)
    {
        // Failed to allocate memory for lexer context
        return  NULL;
    }

    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * in base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 lexer function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function. 
     *
     * We don't use the macros defined in IQLLexer.h here so you can get a sense
     * of what goes where.
     */
    
    /* Create a base lexer, using the supplied input stream
     */
    ctx->pLexer	= antlr3LexerNewStream(ANTLR3_SIZE_HINT, instream, state);
    
    /* Check that we allocated the memory correctly
     */
    if	(ctx->pLexer == NULL)
    {
		ANTLR3_FREE(ctx);
		return  NULL;
    }
    /* Install the implementation of our IQLLexer interface
     */
    ctx->mT__107	= mT__107;
    ctx->mT__108	= mT__108;
    ctx->mT__109	= mT__109;
    ctx->mT__110	= mT__110;
    ctx->mT__111	= mT__111;
    ctx->mT__112	= mT__112;
    ctx->mT__113	= mT__113;
    ctx->mT__114	= mT__114;
    ctx->mT__115	= mT__115;
    ctx->mT__116	= mT__116;
    ctx->mT__117	= mT__117;
    ctx->mT__118	= mT__118;
    ctx->mT__119	= mT__119;
    ctx->mT__120	= mT__120;
    ctx->mT__121	= mT__121;
    ctx->mT__122	= mT__122;
    ctx->mT__123	= mT__123;
    ctx->mT__124	= mT__124;
    ctx->mT__125	= mT__125;
    ctx->mT__126	= mT__126;
    ctx->mT__127	= mT__127;
    ctx->mT__128	= mT__128;
    ctx->mT__129	= mT__129;
    ctx->mT__130	= mT__130;
    ctx->mT__131	= mT__131;
    ctx->mT__132	= mT__132;
    ctx->mT__133	= mT__133;
    ctx->mTK_ADD	= mTK_ADD;
    ctx->mTK_ALL	= mTK_ALL;
    ctx->mTK_ALTER	= mTK_ALTER;
    ctx->mTK_AND	= mTK_AND;
    ctx->mTK_ANY	= mTK_ANY;
    ctx->mTK_AS	= mTK_AS;
    ctx->mTK_ASC	= mTK_ASC;
    ctx->mTK_AVG	= mTK_AVG;
    ctx->mTK_BEGIN	= mTK_BEGIN;
    ctx->mTK_BETWEEN	= mTK_BETWEEN;
    ctx->mTK_BIGINT	= mTK_BIGINT;
    ctx->mTK_BOOLEAN	= mTK_BOOLEAN;
    ctx->mTK_BREAK	= mTK_BREAK;
    ctx->mTK_BY	= mTK_BY;
    ctx->mTK_CASE	= mTK_CASE;
    ctx->mTK_CAST	= mTK_CAST;
    ctx->mTK_CHAR	= mTK_CHAR;
    ctx->mTK_COALESCE	= mTK_COALESCE;
    ctx->mTK_CONTINUE	= mTK_CONTINUE;
    ctx->mTK_COUNT	= mTK_COUNT;
    ctx->mTK_CREATE	= mTK_CREATE;
    ctx->mTK_CROSS	= mTK_CROSS;
    ctx->mTK_DATETIME	= mTK_DATETIME;
    ctx->mTK_DECLARE	= mTK_DECLARE;
    ctx->mTK_DECIMAL	= mTK_DECIMAL;
    ctx->mTK_DESC	= mTK_DESC;
    ctx->mTK_DISTINCT	= mTK_DISTINCT;
    ctx->mTK_DOUBLE	= mTK_DOUBLE;
    ctx->mTK_ELSE	= mTK_ELSE;
    ctx->mTK_END	= mTK_END;
    ctx->mTK_EXISTS	= mTK_EXISTS;
    ctx->mTK_FALSE	= mTK_FALSE;
    ctx->mTK_FROM	= mTK_FROM;
    ctx->mTK_FULL	= mTK_FULL;
    ctx->mTK_FUNCTION	= mTK_FUNCTION;
    ctx->mTK_GROUP	= mTK_GROUP;
    ctx->mTK_HAVING	= mTK_HAVING;
    ctx->mTK_IF	= mTK_IF;
    ctx->mTK_IN	= mTK_IN;
    ctx->mTK_INDEX	= mTK_INDEX;
    ctx->mTK_INNER	= mTK_INNER;
    ctx->mTK_INTO	= mTK_INTO;
    ctx->mTK_INTEGER	= mTK_INTEGER;
    ctx->mTK_INTERVAL	= mTK_INTERVAL;
    ctx->mTK_IS	= mTK_IS;
    ctx->mTK_JOIN	= mTK_JOIN;
    ctx->mTK_KEY	= mTK_KEY;
    ctx->mTK_LEFT	= mTK_LEFT;
    ctx->mTK_LIKE	= mTK_LIKE;
    ctx->mTK_MAX	= mTK_MAX;
    ctx->mTK_MIN	= mTK_MIN;
    ctx->mTK_NOT	= mTK_NOT;
    ctx->mTK_NULL	= mTK_NULL;
    ctx->mTK_NVARCHAR	= mTK_NVARCHAR;
    ctx->mTK_ON	= mTK_ON;
    ctx->mTK_OR	= mTK_OR;
    ctx->mTK_ORDER	= mTK_ORDER;
    ctx->mTK_OUTER	= mTK_OUTER;
    ctx->mTK_OUTPUT	= mTK_OUTPUT;
    ctx->mTK_PRECISION	= mTK_PRECISION;
    ctx->mTK_PRINT	= mTK_PRINT;
    ctx->mTK_PROCEDURE	= mTK_PROCEDURE;
    ctx->mTK_RAISERROR	= mTK_RAISERROR;
    ctx->mTK_RETURN	= mTK_RETURN;
    ctx->mTK_RETURNS	= mTK_RETURNS;
    ctx->mTK_RIGHT	= mTK_RIGHT;
    ctx->mTK_RLIKE	= mTK_RLIKE;
    ctx->mTK_SELECT	= mTK_SELECT;
    ctx->mTK_SET	= mTK_SET;
    ctx->mTK_SOME	= mTK_SOME;
    ctx->mTK_SUM	= mTK_SUM;
    ctx->mTK_SWITCH	= mTK_SWITCH;
    ctx->mTK_THEN	= mTK_THEN;
    ctx->mTK_TRUE	= mTK_TRUE;
    ctx->mTK_UNION	= mTK_UNION;
    ctx->mTK_VARCHAR	= mTK_VARCHAR;
    ctx->mTK_WHEN	= mTK_WHEN;
    ctx->mTK_WHERE	= mTK_WHERE;
    ctx->mTK_WHILE	= mTK_WHILE;
    ctx->mTK_WITH	= mTK_WITH;
    ctx->mSTRING_LITERAL	= mSTRING_LITERAL;
    ctx->mWSTRING_LITERAL	= mWSTRING_LITERAL;
    ctx->mDOUBLE_QUOTED_STRING_LITERAL	= mDOUBLE_QUOTED_STRING_LITERAL;
    ctx->mESCAPE_SEQUENCE	= mESCAPE_SEQUENCE;
    ctx->mOCTAL_ESCAPE	= mOCTAL_ESCAPE;
    ctx->mHEX_DIGIT	= mHEX_DIGIT;
    ctx->mUNICODE_ESCAPE	= mUNICODE_ESCAPE;
    ctx->mWS	= mWS;
    ctx->mML_COMMENT	= mML_COMMENT;
    ctx->mSL_COMMENT	= mSL_COMMENT;
    ctx->mID	= mID;
    ctx->mQUOTED_ID	= mQUOTED_ID;
    ctx->mBIGINT_SUFFIX	= mBIGINT_SUFFIX;
    ctx->mHEX_INTEGER_LITERAL	= mHEX_INTEGER_LITERAL;
    ctx->mDECIMAL_INTEGER_LITERAL	= mDECIMAL_INTEGER_LITERAL;
    ctx->mDECIMAL_BIGINT_LITERAL	= mDECIMAL_BIGINT_LITERAL;
    ctx->mFLOATING_POINT_LITERAL	= mFLOATING_POINT_LITERAL;
    ctx->mEXPONENT	= mEXPONENT;
    ctx->mFLOAT_SUFFIX	= mFLOAT_SUFFIX;
    ctx->mDECIMAL_LITERAL	= mDECIMAL_LITERAL;
    ctx->mTokens	= mTokens;
    
    /** When the nextToken() call is made to this lexer's pANTLR3_TOKEN_SOURCE
     *  it will call mTokens() in this generated code, and will pass it the ctx
     * pointer of this lexer, not the context of the base lexer, so store that now.
     */
    ctx->pLexer->ctx	    = ctx;
    
    /**Install the token matching function
     */
    ctx->pLexer->mTokens = (void (*) (void *))(mTokens);
    
    ctx->getGrammarFileName	= getGrammarFileName;
    ctx->free		= IQLLexerFree;

    
    


    /* Return the newly built lexer to the caller
     */
    return  ctx;
}

/* =========================================================================
 * DFA tables for the lexer
 */
/** Static dfa state tables for Cyclic dfa:
 *    635:1: FLOATING_POINT_LITERAL : ( ( '0' .. '9' )+ '.' ( '0' .. '9' )* EXPONENT ( FLOAT_SUFFIX )? | '.' ( '0' .. '9' )+ EXPONENT ( FLOAT_SUFFIX )? | ( '0' .. '9' )+ ( EXPONENT ( FLOAT_SUFFIX )? | FLOAT_SUFFIX ) );
 */
static const ANTLR3_INT32 dfa25_eot[5] =
    {
	-1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa25_eof[5] =
    {
	-1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa25_min[5] =
    {
	46, 46, -1, -1, -1
    };
static const ANTLR3_INT32 dfa25_max[5] =
    {
	57, 102, -1, -1, -1
    };
static const ANTLR3_INT32 dfa25_accept[5] =
    {
	-1, -1, 2, 3, 1
    };
static const ANTLR3_INT32 dfa25_special[5] =
    {	
	-1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa25_T_empty	    NULL

static const ANTLR3_INT32 dfa25_T0[] =
    {
	4, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 3, 3, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 3, 3
    };static const ANTLR3_INT32 dfa25_T1[] =
    {
	2, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa25_transitions[] =
{
    dfa25_T1, dfa25_T0, dfa25_T_empty, dfa25_T_empty, dfa25_T_empty	
};


/* Declare tracking structure for Cyclic DFA 25
 */
static
ANTLR3_CYCLIC_DFA cdfa25
    =	{
	    25,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"635:1: FLOATING_POINT_LITERAL : ( ( '0' .. '9' )+ '.' ( '0' .. '9' )* EXPONENT ( FLOAT_SUFFIX )? | '.' ( '0' .. '9' )+ EXPONENT ( FLOAT_SUFFIX )? | ( '0' .. '9' )+ ( EXPONENT ( FLOAT_SUFFIX )? | FLOAT_SUFFIX ) );",	
	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa25_eot,	    /* EOT table			    */
	    dfa25_eof,	    /* EOF table			    */
	    dfa25_min,	    /* Minimum tokens for each state    */
	    dfa25_max,	    /* Maximum tokens for each state    */
	    dfa25_accept,	/* Accept table			    */
	    dfa25_special,	/* Special transition states	    */
	    dfa25_transitions	/* Table of transition tables	    */

	};	    
/* End of Cyclic DFA 25
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    1:1: Tokens : ( T__107 | T__108 | T__109 | T__110 | T__111 | T__112 | T__113 | T__114 | T__115 | T__116 | T__117 | T__118 | T__119 | T__120 | T__121 | T__122 | T__123 | T__124 | T__125 | T__126 | T__127 | T__128 | T__129 | T__130 | T__131 | T__132 | T__133 | TK_ADD | TK_ALL | TK_ALTER | TK_AND | TK_ANY | TK_AS | TK_ASC | TK_AVG | TK_BEGIN | TK_BETWEEN | TK_BIGINT | TK_BOOLEAN | TK_BREAK | TK_BY | TK_CASE | TK_CAST | TK_CHAR | TK_COALESCE | TK_CONTINUE | TK_COUNT | TK_CREATE | TK_CROSS | TK_DATETIME | TK_DECLARE | TK_DECIMAL | TK_DESC | TK_DISTINCT | TK_DOUBLE | TK_ELSE | TK_END | TK_EXISTS | TK_FALSE | TK_FROM | TK_FULL | TK_FUNCTION | TK_GROUP | TK_HAVING | TK_IF | TK_IN | TK_INDEX | TK_INNER | TK_INTO | TK_INTEGER | TK_INTERVAL | TK_IS | TK_JOIN | TK_KEY | TK_LEFT | TK_LIKE | TK_MAX | TK_MIN | TK_NOT | TK_NULL | TK_NVARCHAR | TK_ON | TK_OR | TK_ORDER | TK_OUTER | TK_OUTPUT | TK_PRECISION | TK_PRINT | TK_PROCEDURE | TK_RAISERROR | TK_RETURN | TK_RETURNS | TK_RIGHT | TK_RLIKE | TK_SELECT | TK_SET | TK_SOME | TK_SUM | TK_SWITCH | TK_THEN | TK_TRUE | TK_UNION | TK_VARCHAR | TK_WHEN | TK_WHERE | TK_WHILE | TK_WITH | STRING_LITERAL | WSTRING_LITERAL | DOUBLE_QUOTED_STRING_LITERAL | WS | ML_COMMENT | SL_COMMENT | ID | QUOTED_ID | HEX_INTEGER_LITERAL | DECIMAL_INTEGER_LITERAL | DECIMAL_BIGINT_LITERAL | FLOATING_POINT_LITERAL | DECIMAL_LITERAL );
 */
static const ANTLR3_INT32 dfa32_eot[432] =
    {
	-1, -1, -1, -1, -1, -1, 54, 56, -1, -1, -1, -1, -1, -1, -1, -1, 58, 61, 
	-1, 64, -1, -1, -1, -1, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 
	49, 49, 49, 49, 49, 49, 49, 49, 49, 49, -1, -1, -1, -1, -1, 124, 124, -1, 
	-1, 129, -1, -1, -1, -1, -1, -1, -1, -1, -1, 49, 49, 49, 136, 49, 49, 49, 
	49, 49, 143, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 
	49, 165, 169, 170, 49, 49, 49, 49, 49, 49, 49, 49, 49, -1, 180, 182, 49, 
	49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, -1, -1, -1, 
	-1, -1, 129, 124, -1, 204, 205, 49, 207, 208, 209, -1, 210, 49, 49, 49, 
	49, 49, -1, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 231, 49, 
	49, 49, 49, 49, 49, 49, -1, 49, 49, 49, -1, -1, 49, 244, 49, 49, 247, 248, 
	249, 49, 49, -1, 49, -1, 49, 49, 49, 49, 49, 49, 49, 49, 49, 263, 49, 265, 
	49, 49, 49, 49, 49, 49, 49, 49, 129, -1, -1, 49, -1, -1, -1, -1, 49, 49, 
	49, 49, 49, 281, 282, 283, 49, 49, 49, 49, 49, 49, 49, 49, 292, 49, 49, 
	295, -1, 49, 49, 298, 299, 49, 49, 49, 49, 49, 305, 49, 308, -1, 309, 310, 
	-1, -1, -1, 311, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, -1, 324, 
	-1, 49, 326, 327, 49, 49, 330, 49, 49, 333, 334, 335, 49, 49, 49, 339, 
	-1, -1, -1, 49, 49, 342, 49, 344, 49, 49, 49, -1, 49, 49, -1, 49, 351, 
	-1, -1, 49, 353, 49, 355, 356, -1, 49, 49, -1, -1, -1, -1, 49, 360, 361, 
	49, 49, 364, 49, 49, 49, 368, 369, 49, -1, 49, -1, -1, 372, 49, -1, 374, 
	375, -1, -1, -1, 49, 377, 49, -1, 49, 49, -1, 381, -1, 49, 49, 49, 49, 
	386, 387, -1, 49, -1, 389, -1, -1, 49, 49, 49, -1, -1, 393, 49, -1, 49, 
	49, 398, -1, -1, 399, 400, -1, 49, -1, -1, 402, -1, 403, 49, 49, -1, 49, 
	407, 408, 49, -1, -1, 49, -1, 411, 49, 49, -1, 49, 49, 49, 417, -1, -1, 
	-1, 418, -1, -1, 419, 420, 421, -1, -1, 422, 423, -1, 424, 425, 49, 49, 
	49, -1, -1, -1, -1, -1, -1, -1, -1, -1, 429, 430, 431, -1, -1, -1
    };
static const ANTLR3_INT32 dfa32_eof[432] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa32_min[432] =
    {
	9, -1, -1, -1, -1, -1, 62, 48, -1, -1, -1, -1, -1, -1, -1, -1, 61, 61, 
	-1, 42, -1, -1, -1, -1, 68, 69, 65, 65, 76, 65, 82, 65, 70, 79, 69, 69, 
	65, 39, 78, 82, 65, 69, 72, 78, 65, 72, -1, -1, -1, -1, -1, 46, 46, -1, 
	-1, 48, -1, -1, -1, -1, -1, -1, -1, -1, -1, 68, 76, 68, 48, 71, 71, 71, 
	79, 69, 48, 83, 65, 65, 69, 84, 67, 83, 85, 83, 68, 73, 76, 79, 76, 79, 
	86, 48, 48, 48, 73, 89, 70, 75, 88, 78, 84, 76, 65, -1, 48, 48, 84, 69, 
	73, 84, 71, 73, 76, 77, 77, 73, 69, 85, 73, 82, 69, 84, -1, -1, -1, -1, 
	46, 48, 46, -1, 48, 48, 69, 48, 48, 48, -1, 48, 73, 87, 73, 76, 65, -1, 
	69, 82, 76, 84, 78, 65, 83, 69, 73, 67, 84, 66, 69, 48, 83, 83, 77, 76, 
	67, 85, 73, -1, 69, 69, 69, -1, -1, 78, 48, 84, 69, 48, 48, 48, 76, 82, 
	-1, 69, -1, 69, 67, 78, 67, 83, 85, 72, 75, 69, 48, 69, 48, 84, 78, 69, 
	79, 67, 78, 76, 72, 48, -1, -1, 82, -1, -1, -1, -1, 78, 69, 78, 69, 75, 
	48, 48, 48, 69, 73, 84, 84, 83, 84, 65, 77, 48, 73, 76, 48, -1, 84, 69, 
	48, 48, 84, 80, 78, 88, 82, 48, 71, 48, -1, 48, 48, -1, -1, -1, 48, 67, 
	82, 82, 85, 73, 84, 69, 69, 82, 84, 69, 67, -1, 48, -1, 67, 48, 48, 78, 
	72, 48, 69, 69, 48, 48, 48, 69, 84, 65, 48, -1, -1, -1, 83, 78, 48, 69, 
	48, 73, 82, 65, -1, 78, 69, -1, 83, 48, -1, -1, 73, 48, 71, 48, 48, -1, 
	69, 86, -1, -1, -1, -1, 72, 48, 48, 84, 83, 48, 68, 82, 78, 48, 48, 84, 
	-1, 72, -1, -1, 48, 65, -1, 48, 48, -1, -1, -1, 78, 48, 78, -1, 67, 85, 
	-1, 48, -1, 77, 69, 76, 67, 48, 48, -1, 79, -1, 48, -1, -1, 82, 65, 65, 
	-1, -1, 48, 73, -1, 85, 82, 48, -1, -1, 48, 48, -1, 82, -1, -1, 48, -1, 
	48, 69, 69, -1, 69, 48, 48, 84, -1, -1, 78, -1, 48, 76, 82, -1, 79, 82, 
	79, 48, -1, -1, -1, 48, -1, -1, 48, 48, 48, -1, -1, 48, 48, -1, 48, 48, 
	78, 69, 82, -1, -1, -1, -1, -1, -1, -1, -1, -1, 48, 48, 48, -1, -1, -1
    };
static const ANTLR3_INT32 dfa32_max[432] =
    {
	126, -1, -1, -1, -1, -1, 62, 57, -1, -1, -1, -1, -1, -1, -1, -1, 61, 62, 
	-1, 47, -1, -1, -1, -1, 86, 89, 82, 79, 88, 85, 82, 65, 83, 79, 69, 73, 
	73, 86, 85, 82, 76, 87, 82, 78, 65, 73, -1, -1, -1, -1, -1, 120, 102, -1, 
	-1, 101, -1, -1, -1, -1, -1, -1, -1, -1, -1, 68, 84, 89, 122, 71, 84, 71, 
	79, 69, 122, 83, 65, 85, 79, 84, 83, 83, 85, 83, 68, 73, 76, 79, 78, 79, 
	86, 122, 122, 122, 73, 89, 70, 75, 88, 78, 84, 76, 65, -1, 122, 122, 84, 
	79, 73, 84, 71, 73, 84, 77, 77, 73, 69, 85, 73, 82, 73, 84, -1, -1, -1, 
	-1, 102, 101, 102, -1, 122, 122, 69, 122, 122, 122, -1, 122, 73, 87, 73, 
	76, 65, -1, 84, 82, 76, 84, 78, 65, 83, 69, 76, 67, 84, 66, 69, 122, 83, 
	83, 77, 76, 67, 85, 73, -1, 69, 69, 79, -1, -1, 78, 122, 84, 69, 122, 122, 
	122, 76, 82, -1, 69, -1, 80, 67, 78, 67, 83, 85, 72, 75, 69, 122, 69, 122, 
	84, 78, 69, 79, 67, 82, 76, 72, 101, -1, -1, 82, -1, -1, -1, -1, 78, 69, 
	78, 69, 75, 122, 122, 122, 69, 73, 84, 84, 83, 84, 65, 77, 122, 73, 76, 
	122, -1, 84, 69, 122, 122, 84, 80, 78, 88, 82, 122, 82, 122, -1, 122, 122, 
	-1, -1, -1, 122, 67, 82, 82, 85, 73, 84, 69, 69, 82, 84, 69, 67, -1, 122, 
	-1, 67, 122, 122, 78, 72, 122, 69, 69, 122, 122, 122, 69, 84, 65, 122, 
	-1, -1, -1, 83, 78, 122, 69, 122, 73, 82, 65, -1, 78, 69, -1, 83, 122, 
	-1, -1, 73, 122, 71, 122, 122, -1, 69, 86, -1, -1, -1, -1, 72, 122, 122, 
	84, 83, 122, 68, 82, 78, 122, 122, 84, -1, 72, -1, -1, 122, 65, -1, 122, 
	122, -1, -1, -1, 78, 122, 78, -1, 67, 85, -1, 122, -1, 77, 69, 76, 67, 
	122, 122, -1, 79, -1, 122, -1, -1, 82, 65, 65, -1, -1, 122, 73, -1, 85, 
	82, 122, -1, -1, 122, 122, -1, 82, -1, -1, 122, -1, 122, 69, 69, -1, 69, 
	122, 122, 84, -1, -1, 78, -1, 122, 76, 82, -1, 79, 82, 79, 122, -1, -1, 
	-1, 122, -1, -1, 122, 122, 122, -1, -1, 122, 122, -1, 122, 122, 78, 69, 
	82, -1, -1, -1, -1, -1, -1, -1, -1, -1, 122, 122, 122, -1, -1, -1
    };
static const ANTLR3_INT32 dfa32_accept[432] =
    {
	-1, 1, 2, 3, 4, 5, -1, -1, 8, 9, 10, 11, 12, 13, 14, 15, -1, -1, 21, -1, 
	24, 25, 26, 27, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 108, 110, 111, 114, 115, -1, -1, 6, 22, 
	-1, 7, 18, 16, 19, 20, 17, 112, 113, 23, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 109, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 116, 118, 117, 119, 
	-1, -1, -1, 120, -1, -1, -1, -1, -1, -1, 33, -1, -1, -1, -1, -1, -1, 41, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 65, -1, -1, -1, 66, 72, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	82, -1, 83, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, 28, 29, -1, 31, 32, 34, 35, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 57, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 74, -1, -1, 77, 78, 79, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 96, -1, 98, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 42, 43, 44, -1, -1, -1, -1, 
	-1, -1, -1, -1, 53, -1, -1, 56, -1, -1, 60, 61, -1, -1, -1, -1, -1, 69, 
	-1, -1, 73, 75, 76, 80, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	97, -1, 100, 101, -1, -1, 104, -1, -1, 107, 30, 36, -1, -1, -1, 40, -1, 
	-1, 47, -1, 49, -1, -1, -1, -1, -1, -1, 59, -1, 63, -1, 67, 68, -1, -1, 
	-1, 84, 85, -1, -1, 88, -1, -1, -1, 93, 94, -1, -1, 102, -1, 105, 106, 
	-1, 38, -1, -1, -1, 48, -1, -1, -1, -1, 55, 58, -1, 64, -1, -1, -1, 86, 
	-1, -1, -1, -1, 91, 95, 99, -1, 37, 39, -1, -1, -1, 51, 52, -1, -1, 70, 
	-1, -1, -1, -1, -1, 92, 103, 45, 46, 50, 54, 62, 71, 81, -1, -1, -1, 87, 
	89, 90
    };
static const ANTLR3_INT32 dfa32_special[432] =
    {	
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa32_T_empty	    NULL

static const ANTLR3_INT32 dfa32_T0[] =
    {
	49, 49, 49, 49, 49, 49, 49, 49, 49, 49, -1, -1, -1, -1, -1, -1, -1, 49, 
	49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 
	49, 49, 49, 49, 49, 49, 49, -1, -1, -1, -1, 49, -1, 49, 49, 49, 49, 49, 
	49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 
	49, 49, 49
    };static const ANTLR3_INT32 dfa32_T1[] =
    {
	127, -1, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, 125, 125, 125, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 125, 125, 125
    };static const ANTLR3_INT32 dfa32_T2[] =
    {
	184, -1, -1, -1, 185, -1, -1, -1, -1, -1, 186
    };static const ANTLR3_INT32 dfa32_T3[] =
    {
	161, -1, 162
    };static const ANTLR3_INT32 dfa32_T4[] =
    {
	55, 55, 55, 55, 55, 55, 55, 55, 55, 55
    };static const ANTLR3_INT32 dfa32_T5[] =
    {
	103, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 100, -1, -1, -1, -1, -1, 101, 102
    };static const ANTLR3_INT32 dfa32_T6[] =
    {
	55, 55, 55, 55, 55, 55, 55, 55, 55, 55, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 125, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 125
    };static const ANTLR3_INT32 dfa32_T7[] =
    {
	91, -1, -1, -1, -1, -1, -1, -1, 92, -1, -1, -1, -1, 93
    };static const ANTLR3_INT32 dfa32_T8[] =
    {
	79, -1, -1, -1, 80, -1, -1, -1, 81, -1, -1, -1, -1, -1, 82
    };static const ANTLR3_INT32 dfa32_T9[] =
    {
	127, -1, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, 125, 125, 125, -1, -1, -1, -1, -1, 123, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 125, 125, 125
    };static const ANTLR3_INT32 dfa32_T10[] =
    {
	108, -1, -1, -1, 109, -1, -1, -1, 110, -1, -1, 111
    };static const ANTLR3_INT32 dfa32_T11[] =
    {
	280
    };static const ANTLR3_INT32 dfa32_T12[] =
    {
	145
    };static const ANTLR3_INT32 dfa32_T13[] =
    {
	218
    };static const ANTLR3_INT32 dfa32_T14[] =
    {
	140
    };static const ANTLR3_INT32 dfa32_T15[] =
    {
	337
    };static const ANTLR3_INT32 dfa32_T16[] =
    {
	278
    };static const ANTLR3_INT32 dfa32_T17[] =
    {
	213
    };static const ANTLR3_INT32 dfa32_T18[] =
    {
	277
    };static const ANTLR3_INT32 dfa32_T19[] =
    {
	212
    };static const ANTLR3_INT32 dfa32_T20[] =
    {
	86, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 87, 
	-1, -1, 88
    };static const ANTLR3_INT32 dfa32_T21[] =
    {
	376
    };static const ANTLR3_INT32 dfa32_T22[] =
    {
	336
    };static const ANTLR3_INT32 dfa32_T23[] =
    {
	378
    };static const ANTLR3_INT32 dfa32_T24[] =
    {
	107
    };static const ANTLR3_INT32 dfa32_T25[] =
    {
	142
    };static const ANTLR3_INT32 dfa32_T26[] =
    {
	215
    };static const ANTLR3_INT32 dfa32_T27[] =
    {
	306, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 307
    };static const ANTLR3_INT32 dfa32_T28[] =
    {
	279
    };static const ANTLR3_INT32 dfa32_T29[] =
    {
	338
    };static const ANTLR3_INT32 dfa32_T30[] =
    {
	141
    };static const ANTLR3_INT32 dfa32_T31[] =
    {
	214
    };static const ANTLR3_INT32 dfa32_T32[] =
    {
	211
    };static const ANTLR3_INT32 dfa32_T33[] =
    {
	146, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 147, -1, -1, -1, -1, 
	-1, -1, 148
    };static const ANTLR3_INT32 dfa32_T34[] =
    {
	276
    };static const ANTLR3_INT32 dfa32_T35[] =
    {
	137
    };static const ANTLR3_INT32 dfa32_T36[] =
    {
	130
    };static const ANTLR3_INT32 dfa32_T37[] =
    {
	275
    };static const ANTLR3_INT32 dfa32_T38[] =
    {
	206
    };static const ANTLR3_INT32 dfa32_T39[] =
    {
	157
    };static const ANTLR3_INT32 dfa32_T40[] =
    {
	232
    };static const ANTLR3_INT32 dfa32_T41[] =
    {
	158
    };static const ANTLR3_INT32 dfa32_T42[] =
    {
	350
    };static const ANTLR3_INT32 dfa32_T43[] =
    {
	296
    };static const ANTLR3_INT32 dfa32_T44[] =
    {
	159
    };static const ANTLR3_INT32 dfa32_T45[] =
    {
	294
    };static const ANTLR3_INT32 dfa32_T46[] =
    {
	349
    };static const ANTLR3_INT32 dfa32_T47[] =
    {
	155
    };static const ANTLR3_INT32 dfa32_T48[] =
    {
	229
    };static const ANTLR3_INT32 dfa32_T49[] =
    {
	230
    };static const ANTLR3_INT32 dfa32_T50[] =
    {
	156
    };static const ANTLR3_INT32 dfa32_T51[] =
    {
	154
    };static const ANTLR3_INT32 dfa32_T52[] =
    {
	49, 49, 49, 49, 49, 49, 49, 49, 49, 49, -1, -1, -1, -1, -1, -1, -1, 49, 
	49, 49, 166, 49, 49, 49, 49, 49, 49, 49, 49, 49, 167, 49, 49, 49, 49, 49, 
	168, 49, 49, 49, 49, 49, 49, -1, -1, -1, -1, 49, -1, 49, 49, 49, 49, 49, 
	49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 
	49, 49, 49
    };static const ANTLR3_INT32 dfa32_T53[] =
    {
	293
    };static const ANTLR3_INT32 dfa32_T54[] =
    {
	228
    };static const ANTLR3_INT32 dfa32_T55[] =
    {
	385
    };static const ANTLR3_INT32 dfa32_T56[] =
    {
	49, 49, 49, 49, 49, 49, 49, 49, 49, 49, -1, -1, -1, -1, -1, -1, -1, 49, 
	49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 397, 
	49, 49, 49, 49, 49, 49, 49, -1, -1, -1, -1, 49, -1, 49, 49, 49, 49, 49, 
	49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 
	49, 49, 49
    };static const ANTLR3_INT32 dfa32_T57[] =
    {
	348
    };static const ANTLR3_INT32 dfa32_T58[] =
    {
	409
    };static const ANTLR3_INT32 dfa32_T59[] =
    {
	291
    };static const ANTLR3_INT32 dfa32_T60[] =
    {
	347
    };static const ANTLR3_INT32 dfa32_T61[] =
    {
	384
    };static const ANTLR3_INT32 dfa32_T62[] =
    {
	227
    };static const ANTLR3_INT32 dfa32_T63[] =
    {
	406
    };static const ANTLR3_INT32 dfa32_T64[] =
    {
	382
    };static const ANTLR3_INT32 dfa32_T65[] =
    {
	345
    };static const ANTLR3_INT32 dfa32_T66[] =
    {
	289
    };static const ANTLR3_INT32 dfa32_T67[] =
    {
	224
    };static const ANTLR3_INT32 dfa32_T68[] =
    {
	383
    };static const ANTLR3_INT32 dfa32_T69[] =
    {
	346
    };static const ANTLR3_INT32 dfa32_T70[] =
    {
	290
    };static const ANTLR3_INT32 dfa32_T71[] =
    {
	96, -1, -1, -1, 97
    };static const ANTLR3_INT32 dfa32_T72[] =
    {
	253, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 254
    };static const ANTLR3_INT32 dfa32_T73[] =
    {
	287
    };static const ANTLR3_INT32 dfa32_T74[] =
    {
	183
    };static const ANTLR3_INT32 dfa32_T75[] =
    {
	343
    };static const ANTLR3_INT32 dfa32_T76[] =
    {
	151
    };static const ANTLR3_INT32 dfa32_T77[] =
    {
	223
    };static const ANTLR3_INT32 dfa32_T78[] =
    {
	288
    };static const ANTLR3_INT32 dfa32_T79[] =
    {
	221
    };static const ANTLR3_INT32 dfa32_T80[] =
    {
	405
    };static const ANTLR3_INT32 dfa32_T81[] =
    {
	222
    };static const ANTLR3_INT32 dfa32_T82[] =
    {
	286
    };static const ANTLR3_INT32 dfa32_T83[] =
    {
	65, -1, -1, -1, -1, -1, -1, -1, 66, -1, 67, -1, -1, -1, -1, 68, -1, -1, 
	69
    };static const ANTLR3_INT32 dfa32_T84[] =
    {
	379
    };static const ANTLR3_INT32 dfa32_T85[] =
    {
	404
    };static const ANTLR3_INT32 dfa32_T86[] =
    {
	219
    };static const ANTLR3_INT32 dfa32_T87[] =
    {
	284
    };static const ANTLR3_INT32 dfa32_T88[] =
    {
	340
    };static const ANTLR3_INT32 dfa32_T89[] =
    {
	220
    };static const ANTLR3_INT32 dfa32_T90[] =
    {
	285
    };static const ANTLR3_INT32 dfa32_T91[] =
    {
	341
    };static const ANTLR3_INT32 dfa32_T92[] =
    {
	380
    };static const ANTLR3_INT32 dfa32_T93[] =
    {
	245
    };static const ANTLR3_INT32 dfa32_T94[] =
    {
	173
    };static const ANTLR3_INT32 dfa32_T95[] =
    {
	172
    };static const ANTLR3_INT32 dfa32_T96[] =
    {
	152, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 153
    };static const ANTLR3_INT32 dfa32_T97[] =
    {
	243
    };static const ANTLR3_INT32 dfa32_T98[] =
    {
	171
    };static const ANTLR3_INT32 dfa32_T99[] =
    {
	48, 48, -1, 48, 48, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 48, -1, 47, 22, 23, 20, 15, 46, 9, 10, 8, 18, 5, 6, 
	7, 19, 51, 52, 52, 52, 52, 52, 52, 52, 52, 52, 12, 1, 17, 2, 16, 11, -1, 
	24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 49, 40, 
	41, 42, 43, 44, 45, 49, 49, 49, 3, -1, 4, 13, 49, 50, 49, 49, 49, 49, 49, 
	49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 
	49, 49, 49, -1, 14, -1, 21
    };static const ANTLR3_INT32 dfa32_T100[] =
    {
	412
    };static const ANTLR3_INT32 dfa32_T101[] =
    {
	391
    };static const ANTLR3_INT32 dfa32_T102[] =
    {
	358
    };static const ANTLR3_INT32 dfa32_T103[] =
    {
	357
    };static const ANTLR3_INT32 dfa32_T104[] =
    {
	390
    };static const ANTLR3_INT32 dfa32_T105[] =
    {
	304
    };static const ANTLR3_INT32 dfa32_T106[] =
    {
	240
    };static const ANTLR3_INT32 dfa32_T107[] =
    {
	239
    };static const ANTLR3_INT32 dfa32_T108[] =
    {
	303
    };static const ANTLR3_INT32 dfa32_T109[] =
    {
	354
    };static const ANTLR3_INT32 dfa32_T110[] =
    {
	302
    };static const ANTLR3_INT32 dfa32_T111[] =
    {
	238
    };static const ANTLR3_INT32 dfa32_T112[] =
    {
	164
    };static const ANTLR3_INT32 dfa32_T113[] =
    {
	259
    };static const ANTLR3_INT32 dfa32_T114[] =
    {
	188
    };static const ANTLR3_INT32 dfa32_T115[] =
    {
	301
    };static const ANTLR3_INT32 dfa32_T116[] =
    {
	367
    };static const ANTLR3_INT32 dfa32_T117[] =
    {
	237
    };static const ANTLR3_INT32 dfa32_T118[] =
    {
	163
    };static const ANTLR3_INT32 dfa32_T119[] =
    {
	320
    };static const ANTLR3_INT32 dfa32_T120[] =
    {
	352
    };static const ANTLR3_INT32 dfa32_T121[] =
    {
	388
    };static const ANTLR3_INT32 dfa32_T122[] =
    {
	410
    };static const ANTLR3_INT32 dfa32_T123[] =
    {
	236
    };static const ANTLR3_INT32 dfa32_T124[] =
    {
	300
    };static const ANTLR3_INT32 dfa32_T125[] =
    {
	235
    };static const ANTLR3_INT32 dfa32_T126[] =
    {
	234
    };static const ANTLR3_INT32 dfa32_T127[] =
    {
	160
    };static const ANTLR3_INT32 dfa32_T128[] =
    {
	297
    };static const ANTLR3_INT32 dfa32_T129[] =
    {
	233
    };static const ANTLR3_INT32 dfa32_T130[] =
    {
	200, -1, -1, -1, 201
    };static const ANTLR3_INT32 dfa32_T131[] =
    {
	176
    };static const ANTLR3_INT32 dfa32_T132[] =
    {
	131, -1, -1, -1, -1, -1, -1, -1, 132
    };static const ANTLR3_INT32 dfa32_T133[] =
    {
	174
    };static const ANTLR3_INT32 dfa32_T134[] =
    {
	246
    };static const ANTLR3_INT32 dfa32_T135[] =
    {
	175
    };static const ANTLR3_INT32 dfa32_T136[] =
    {
	250
    };static const ANTLR3_INT32 dfa32_T137[] =
    {
	178
    };static const ANTLR3_INT32 dfa32_T138[] =
    {
	177
    };static const ANTLR3_INT32 dfa32_T139[] =
    {
	89
    };static const ANTLR3_INT32 dfa32_T140[] =
    {
	133, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 134
    };static const ANTLR3_INT32 dfa32_T141[] =
    {
	104, -1, -1, -1, 105, -1, -1, 106
    };static const ANTLR3_INT32 dfa32_T142[] =
    {
	179
    };static const ANTLR3_INT32 dfa32_T143[] =
    {
	90
    };static const ANTLR3_INT32 dfa32_T144[] =
    {
	251
    };static const ANTLR3_INT32 dfa32_T145[] =
    {
	312
    };static const ANTLR3_INT32 dfa32_T146[] =
    {
	359
    };static const ANTLR3_INT32 dfa32_T147[] =
    {
	392
    };static const ANTLR3_INT32 dfa32_T148[] =
    {
	413
    };static const ANTLR3_INT32 dfa32_T149[] =
    {
	314
    };static const ANTLR3_INT32 dfa32_T150[] =
    {
	313
    };static const ANTLR3_INT32 dfa32_T151[] =
    {
	252
    };static const ANTLR3_INT32 dfa32_T152[] =
    {
	255
    };static const ANTLR3_INT32 dfa32_T153[] =
    {
	83, -1, 84, -1, -1, -1, -1, -1, -1, -1, -1, -1, 85
    };static const ANTLR3_INT32 dfa32_T154[] =
    {
	362
    };static const ANTLR3_INT32 dfa32_T155[] =
    {
	315
    };static const ANTLR3_INT32 dfa32_T156[] =
    {
	317
    };static const ANTLR3_INT32 dfa32_T157[] =
    {
	256
    };static const ANTLR3_INT32 dfa32_T158[] =
    {
	75, -1, -1, -1, -1, -1, -1, 76, -1, -1, -1, -1, -1, -1, 77, -1, -1, 78
    };static const ANTLR3_INT32 dfa32_T159[] =
    {
	426
    };static const ANTLR3_INT32 dfa32_T160[] =
    {
	414
    };static const ANTLR3_INT32 dfa32_T161[] =
    {
	394
    };static const ANTLR3_INT32 dfa32_T162[] =
    {
	363
    };static const ANTLR3_INT32 dfa32_T163[] =
    {
	316
    };static const ANTLR3_INT32 dfa32_T164[] =
    {
	271, -1, -1, -1, 272
    };static const ANTLR3_INT32 dfa32_T165[] =
    {
	187
    };static const ANTLR3_INT32 dfa32_T166[] =
    {
	258
    };static const ANTLR3_INT32 dfa32_T167[] =
    {
	427
    };static const ANTLR3_INT32 dfa32_T168[] =
    {
	94
    };static const ANTLR3_INT32 dfa32_T169[] =
    {
	318
    };static const ANTLR3_INT32 dfa32_T170[] =
    {
	138, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 139
    };static const ANTLR3_INT32 dfa32_T171[] =
    {
	365
    };static const ANTLR3_INT32 dfa32_T172[] =
    {
	395
    };static const ANTLR3_INT32 dfa32_T173[] =
    {
	415
    };static const ANTLR3_INT32 dfa32_T174[] =
    {
	120, 121
    };static const ANTLR3_INT32 dfa32_T175[] =
    {
	257
    };static const ANTLR3_INT32 dfa32_T176[] =
    {
	49, 49, 49, 49, 49, 49, 49, 49, 49, 49, -1, -1, -1, -1, -1, -1, -1, 49, 
	49, 49, 181, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 
	49, 49, 49, 49, 49, 49, 49, -1, -1, -1, -1, 49, -1, 49, 49, 49, 49, 49, 
	49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 
	49, 49, 49
    };static const ANTLR3_INT32 dfa32_T177[] =
    {
	428
    };static const ANTLR3_INT32 dfa32_T178[] =
    {
	366
    };static const ANTLR3_INT32 dfa32_T179[] =
    {
	319
    };static const ANTLR3_INT32 dfa32_T180[] =
    {
	416
    };static const ANTLR3_INT32 dfa32_T181[] =
    {
	396
    };static const ANTLR3_INT32 dfa32_T182[] =
    {
	53
    };static const ANTLR3_INT32 dfa32_T183[] =
    {
	321
    };static const ANTLR3_INT32 dfa32_T184[] =
    {
	260
    };static const ANTLR3_INT32 dfa32_T185[] =
    {
	189
    };static const ANTLR3_INT32 dfa32_T186[] =
    {
	261
    };static const ANTLR3_INT32 dfa32_T187[] =
    {
	322
    };static const ANTLR3_INT32 dfa32_T188[] =
    {
	190
    };static const ANTLR3_INT32 dfa32_T189[] =
    {
	57
    };static const ANTLR3_INT32 dfa32_T190[] =
    {
	262
    };static const ANTLR3_INT32 dfa32_T191[] =
    {
	323
    };static const ANTLR3_INT32 dfa32_T192[] =
    {
	370
    };static const ANTLR3_INT32 dfa32_T193[] =
    {
	264
    };static const ANTLR3_INT32 dfa32_T194[] =
    {
	193
    };static const ANTLR3_INT32 dfa32_T195[] =
    {
	194
    };static const ANTLR3_INT32 dfa32_T196[] =
    {
	195
    };static const ANTLR3_INT32 dfa32_T197[] =
    {
	266
    };static const ANTLR3_INT32 dfa32_T198[] =
    {
	325
    };static const ANTLR3_INT32 dfa32_T199[] =
    {
	371
    };static const ANTLR3_INT32 dfa32_T200[] =
    {
	203, 203, 203, 203, 203, 203, 203, 203, 203, 203, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 125, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 125
    };static const ANTLR3_INT32 dfa32_T201[] =
    {
	267
    };static const ANTLR3_INT32 dfa32_T202[] =
    {
	196
    };static const ANTLR3_INT32 dfa32_T203[] =
    {
	216, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 217
    };static const ANTLR3_INT32 dfa32_T204[] =
    {
	268
    };static const ANTLR3_INT32 dfa32_T205[] =
    {
	197
    };static const ANTLR3_INT32 dfa32_T206[] =
    {
	144
    };static const ANTLR3_INT32 dfa32_T207[] =
    {
	328
    };static const ANTLR3_INT32 dfa32_T208[] =
    {
	198
    };static const ANTLR3_INT32 dfa32_T209[] =
    {
	269
    };static const ANTLR3_INT32 dfa32_T210[] =
    {
	401
    };static const ANTLR3_INT32 dfa32_T211[] =
    {
	329
    };static const ANTLR3_INT32 dfa32_T212[] =
    {
	373
    };static const ANTLR3_INT32 dfa32_T213[] =
    {
	199
    };static const ANTLR3_INT32 dfa32_T214[] =
    {
	270
    };static const ANTLR3_INT32 dfa32_T215[] =
    {
	331
    };static const ANTLR3_INT32 dfa32_T216[] =
    {
	273
    };static const ANTLR3_INT32 dfa32_T217[] =
    {
	332
    };static const ANTLR3_INT32 dfa32_T218[] =
    {
	202
    };static const ANTLR3_INT32 dfa32_T219[] =
    {
	116, -1, -1, -1, -1, -1, -1, -1, -1, -1, 117
    };static const ANTLR3_INT32 dfa32_T220[] =
    {
	191, -1, -1, -1, -1, -1, -1, -1, 192
    };static const ANTLR3_INT32 dfa32_T221[] =
    {
	274
    };static const ANTLR3_INT32 dfa32_T222[] =
    {
	62, -1, -1, -1, -1, 63
    };static const ANTLR3_INT32 dfa32_T223[] =
    {
	59, 60
    };static const ANTLR3_INT32 dfa32_T224[] =
    {
	149, -1, -1, -1, -1, -1, -1, -1, -1, -1, 150
    };static const ANTLR3_INT32 dfa32_T225[] =
    {
	70, -1, -1, -1, 71, -1, -1, -1, -1, -1, 72, -1, -1, 73, -1, -1, -1, -1, 
	-1, -1, 74
    };static const ANTLR3_INT32 dfa32_T226[] =
    {
	118
    };static const ANTLR3_INT32 dfa32_T227[] =
    {
	98, -1, -1, -1, -1, -1, -1, -1, 99
    };static const ANTLR3_INT32 dfa32_T228[] =
    {
	119
    };static const ANTLR3_INT32 dfa32_T229[] =
    {
	226, -1, -1, 225
    };static const ANTLR3_INT32 dfa32_T230[] =
    {
	95
    };static const ANTLR3_INT32 dfa32_T231[] =
    {
	242, -1, -1, -1, -1, -1, -1, -1, -1, -1, 241
    };static const ANTLR3_INT32 dfa32_T232[] =
    {
	127, -1, 126, 126, 126, 126, 126, 126, 126, 126, 126, 126, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, 125, 125, 125, -1, -1, -1, -1, -1, 123, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 122, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 125, 125, 125, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, 122
    };static const ANTLR3_INT32 dfa32_T233[] =
    {
	112, -1, -1, -1, -1, -1, -1, -1, -1, -1, 113, -1, -1, -1, -1, -1, 114, 
	-1, 115
    };static const ANTLR3_INT32 dfa32_T234[] =
    {
	49, 49, 49, 49, 49, 49, 49, 49, 49, 49, -1, -1, -1, -1, -1, -1, -1, 49, 
	49, 135, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 
	49, 49, 49, 49, 49, 49, 49, -1, -1, -1, -1, 49, -1, 49, 49, 49, 49, 49, 
	49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 
	49, 49, 49
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa32_transitions[] =
{
    dfa32_T99, dfa32_T_empty, dfa32_T_empty, dfa32_T_empty, dfa32_T_empty, 
    dfa32_T_empty, dfa32_T182, dfa32_T4, dfa32_T_empty, dfa32_T_empty, dfa32_T_empty, 
    dfa32_T_empty, dfa32_T_empty, dfa32_T_empty, dfa32_T_empty, dfa32_T_empty, 
    dfa32_T189, dfa32_T223, dfa32_T_empty, dfa32_T222, dfa32_T_empty, dfa32_T_empty, 
    dfa32_T_empty, dfa32_T_empty, dfa32_T83, dfa32_T225, dfa32_T158, dfa32_T8, 
    dfa32_T153, dfa32_T20, dfa32_T139, dfa32_T143, dfa32_T7, dfa32_T168, 
    dfa32_T230, dfa32_T71, dfa32_T227, dfa32_T5, dfa32_T141, dfa32_T24, 
    dfa32_T10, dfa32_T233, dfa32_T219, dfa32_T226, dfa32_T228, dfa32_T174, 
    dfa32_T_empty, dfa32_T_empty, dfa32_T_empty, dfa32_T_empty, dfa32_T_empty, 
    dfa32_T232, dfa32_T9, dfa32_T_empty, dfa32_T_empty, dfa32_T6, dfa32_T_empty, 
    dfa32_T_empty, dfa32_T_empty, dfa32_T_empty, dfa32_T_empty, dfa32_T_empty, 
    dfa32_T_empty, dfa32_T_empty, dfa32_T_empty, dfa32_T36, dfa32_T132, 
    dfa32_T140, dfa32_T234, dfa32_T35, dfa32_T170, dfa32_T14, dfa32_T30, 
    dfa32_T25, dfa32_T0, dfa32_T206, dfa32_T12, dfa32_T33, dfa32_T224, dfa32_T76, 
    dfa32_T96, dfa32_T51, dfa32_T47, dfa32_T50, dfa32_T39, dfa32_T41, dfa32_T44, 
    dfa32_T127, dfa32_T3, dfa32_T118, dfa32_T112, dfa32_T0, dfa32_T52, dfa32_T0, 
    dfa32_T98, dfa32_T95, dfa32_T94, dfa32_T133, dfa32_T135, dfa32_T131, 
    dfa32_T138, dfa32_T137, dfa32_T142, dfa32_T_empty, dfa32_T0, dfa32_T176, 
    dfa32_T74, dfa32_T2, dfa32_T165, dfa32_T114, dfa32_T185, dfa32_T188, 
    dfa32_T220, dfa32_T194, dfa32_T195, dfa32_T196, dfa32_T202, dfa32_T205, 
    dfa32_T208, dfa32_T213, dfa32_T130, dfa32_T218, dfa32_T_empty, dfa32_T_empty, 
    dfa32_T_empty, dfa32_T_empty, dfa32_T1, dfa32_T200, dfa32_T9, dfa32_T_empty, 
    dfa32_T0, dfa32_T0, dfa32_T38, dfa32_T0, dfa32_T0, dfa32_T0, dfa32_T_empty, 
    dfa32_T0, dfa32_T32, dfa32_T19, dfa32_T17, dfa32_T31, dfa32_T26, dfa32_T_empty, 
    dfa32_T203, dfa32_T13, dfa32_T86, dfa32_T89, dfa32_T79, dfa32_T81, dfa32_T77, 
    dfa32_T67, dfa32_T229, dfa32_T62, dfa32_T54, dfa32_T48, dfa32_T49, dfa32_T0, 
    dfa32_T40, dfa32_T129, dfa32_T126, dfa32_T125, dfa32_T123, dfa32_T117, 
    dfa32_T111, dfa32_T_empty, dfa32_T107, dfa32_T106, dfa32_T231, dfa32_T_empty, 
    dfa32_T_empty, dfa32_T97, dfa32_T0, dfa32_T93, dfa32_T134, dfa32_T0, 
    dfa32_T0, dfa32_T0, dfa32_T136, dfa32_T144, dfa32_T_empty, dfa32_T151, 
    dfa32_T_empty, dfa32_T72, dfa32_T152, dfa32_T157, dfa32_T175, dfa32_T166, 
    dfa32_T113, dfa32_T184, dfa32_T186, dfa32_T190, dfa32_T0, dfa32_T193, 
    dfa32_T0, dfa32_T197, dfa32_T201, dfa32_T204, dfa32_T209, dfa32_T214, 
    dfa32_T164, dfa32_T216, dfa32_T221, dfa32_T200, dfa32_T_empty, dfa32_T_empty, 
    dfa32_T37, dfa32_T_empty, dfa32_T_empty, dfa32_T_empty, dfa32_T_empty, 
    dfa32_T34, dfa32_T18, dfa32_T16, dfa32_T28, dfa32_T11, dfa32_T0, dfa32_T0, 
    dfa32_T0, dfa32_T87, dfa32_T90, dfa32_T82, dfa32_T73, dfa32_T78, dfa32_T66, 
    dfa32_T70, dfa32_T59, dfa32_T0, dfa32_T53, dfa32_T45, dfa32_T0, dfa32_T_empty, 
    dfa32_T43, dfa32_T128, dfa32_T0, dfa32_T0, dfa32_T124, dfa32_T115, dfa32_T110, 
    dfa32_T108, dfa32_T105, dfa32_T0, dfa32_T27, dfa32_T0, dfa32_T_empty, 
    dfa32_T0, dfa32_T0, dfa32_T_empty, dfa32_T_empty, dfa32_T_empty, dfa32_T0, 
    dfa32_T145, dfa32_T150, dfa32_T149, dfa32_T155, dfa32_T163, dfa32_T156, 
    dfa32_T169, dfa32_T179, dfa32_T119, dfa32_T183, dfa32_T187, dfa32_T191, 
    dfa32_T_empty, dfa32_T0, dfa32_T_empty, dfa32_T198, dfa32_T0, dfa32_T0, 
    dfa32_T207, dfa32_T211, dfa32_T0, dfa32_T215, dfa32_T217, dfa32_T0, 
    dfa32_T0, dfa32_T0, dfa32_T22, dfa32_T15, dfa32_T29, dfa32_T0, dfa32_T_empty, 
    dfa32_T_empty, dfa32_T_empty, dfa32_T88, dfa32_T91, dfa32_T0, dfa32_T75, 
    dfa32_T0, dfa32_T65, dfa32_T69, dfa32_T60, dfa32_T_empty, dfa32_T57, 
    dfa32_T46, dfa32_T_empty, dfa32_T42, dfa32_T0, dfa32_T_empty, dfa32_T_empty, 
    dfa32_T120, dfa32_T0, dfa32_T109, dfa32_T0, dfa32_T0, dfa32_T_empty, 
    dfa32_T103, dfa32_T102, dfa32_T_empty, dfa32_T_empty, dfa32_T_empty, 
    dfa32_T_empty, dfa32_T146, dfa32_T0, dfa32_T0, dfa32_T154, dfa32_T162, 
    dfa32_T0, dfa32_T171, dfa32_T178, dfa32_T116, dfa32_T0, dfa32_T0, dfa32_T192, 
    dfa32_T_empty, dfa32_T199, dfa32_T_empty, dfa32_T_empty, dfa32_T0, dfa32_T212, 
    dfa32_T_empty, dfa32_T0, dfa32_T0, dfa32_T_empty, dfa32_T_empty, dfa32_T_empty, 
    dfa32_T21, dfa32_T0, dfa32_T23, dfa32_T_empty, dfa32_T84, dfa32_T92, 
    dfa32_T_empty, dfa32_T0, dfa32_T_empty, dfa32_T64, dfa32_T68, dfa32_T61, 
    dfa32_T55, dfa32_T0, dfa32_T0, dfa32_T_empty, dfa32_T121, dfa32_T_empty, 
    dfa32_T0, dfa32_T_empty, dfa32_T_empty, dfa32_T104, dfa32_T101, dfa32_T147, 
    dfa32_T_empty, dfa32_T_empty, dfa32_T0, dfa32_T161, dfa32_T_empty, dfa32_T172, 
    dfa32_T181, dfa32_T56, dfa32_T_empty, dfa32_T_empty, dfa32_T0, dfa32_T0, 
    dfa32_T_empty, dfa32_T210, dfa32_T_empty, dfa32_T_empty, dfa32_T0, dfa32_T_empty, 
    dfa32_T0, dfa32_T85, dfa32_T80, dfa32_T_empty, dfa32_T63, dfa32_T0, 
    dfa32_T0, dfa32_T58, dfa32_T_empty, dfa32_T_empty, dfa32_T122, dfa32_T_empty, 
    dfa32_T0, dfa32_T100, dfa32_T148, dfa32_T_empty, dfa32_T160, dfa32_T173, 
    dfa32_T180, dfa32_T0, dfa32_T_empty, dfa32_T_empty, dfa32_T_empty, dfa32_T0, 
    dfa32_T_empty, dfa32_T_empty, dfa32_T0, dfa32_T0, dfa32_T0, dfa32_T_empty, 
    dfa32_T_empty, dfa32_T0, dfa32_T0, dfa32_T_empty, dfa32_T0, dfa32_T0, 
    dfa32_T159, dfa32_T167, dfa32_T177, dfa32_T_empty, dfa32_T_empty, dfa32_T_empty, 
    dfa32_T_empty, dfa32_T_empty, dfa32_T_empty, dfa32_T_empty, dfa32_T_empty, 
    dfa32_T_empty, dfa32_T0, dfa32_T0, dfa32_T0, dfa32_T_empty, dfa32_T_empty, 
    dfa32_T_empty	
};


/* Declare tracking structure for Cyclic DFA 32
 */
static
ANTLR3_CYCLIC_DFA cdfa32
    =	{
	    32,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"1:1: Tokens : ( T__107 | T__108 | T__109 | T__110 | T__111 | T__112 | T__113 | T__114 | T__115 | T__116 | T__117 | T__118 | T__119 | T__120 | T__121 | T__122 | T__123 | T__124 | T__125 | T__126 | T__127 | T__128 | T__129 | T__130 | T__131 | T__132 | T__133 | TK_ADD | TK_ALL | TK_ALTER | TK_AND | TK_ANY | TK_AS | TK_ASC | TK_AVG | TK_BEGIN | TK_BETWEEN | TK_BIGINT | TK_BOOLEAN | TK_BREAK | TK_BY | TK_CASE | TK_CAST | TK_CHAR | TK_COALESCE | TK_CONTINUE | TK_COUNT | TK_CREATE | TK_CROSS | TK_DATETIME | TK_DECLARE | TK_DECIMAL | TK_DESC | TK_DISTINCT | TK_DOUBLE | TK_ELSE | TK_END | TK_EXISTS | TK_FALSE | TK_FROM | TK_FULL | TK_FUNCTION | TK_GROUP | TK_HAVING | TK_IF | TK_IN | TK_INDEX | TK_INNER | TK_INTO | TK_INTEGER | TK_INTERVAL | TK_IS | TK_JOIN | TK_KEY | TK_LEFT | TK_LIKE | TK_MAX | TK_MIN | TK_NOT | TK_NULL | TK_NVARCHAR | TK_ON | TK_OR | TK_ORDER | TK_OUTER | TK_OUTPUT | TK_PRECISION | TK_PRINT | TK_PROCEDURE | TK_RAISERROR | TK_RETURN | TK_RETURNS | TK_RIGHT | TK_RLIKE | TK_SELECT | TK_SET | TK_SOME | TK_SUM | TK_SWITCH | TK_THEN | TK_TRUE | TK_UNION | TK_VARCHAR | TK_WHEN | TK_WHERE | TK_WHILE | TK_WITH | STRING_LITERAL | WSTRING_LITERAL | DOUBLE_QUOTED_STRING_LITERAL | WS | ML_COMMENT | SL_COMMENT | ID | QUOTED_ID | HEX_INTEGER_LITERAL | DECIMAL_INTEGER_LITERAL | DECIMAL_BIGINT_LITERAL | FLOATING_POINT_LITERAL | DECIMAL_LITERAL );",	
	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa32_eot,	    /* EOT table			    */
	    dfa32_eof,	    /* EOF table			    */
	    dfa32_min,	    /* Minimum tokens for each state    */
	    dfa32_max,	    /* Maximum tokens for each state    */
	    dfa32_accept,	/* Accept table			    */
	    dfa32_special,	/* Special transition states	    */
	    dfa32_transitions	/* Table of transition tables	    */

	};	    
/* End of Cyclic DFA 32
 * ---------------------
 */ 
/* =========================================================================
 * End of DFA tables for the lexer
 */ 

/* =========================================================================
 * Functions to match the lexer grammar defined tokens from the input stream
 */

//   Comes from: 7:8: ( ';' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__107
 *
 * Looks to match the characters the constitute the token T__107
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__107(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__107;
       
    
    // IQL.g:7:8: ( ';' )
    // IQL.g:7:10: ';'
    {
        MATCHC(';'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__107Ex;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__107Ex; /* Prevent compiler warnings */
    ruleT__107Ex: ;

}
// $ANTLR end T__107

//   Comes from: 8:8: ( '=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__108
 *
 * Looks to match the characters the constitute the token T__108
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__108(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__108;
       
    
    // IQL.g:8:8: ( '=' )
    // IQL.g:8:10: '='
    {
        MATCHC('='); 
        if  (HASEXCEPTION())
        {
            goto ruleT__108Ex;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__108Ex; /* Prevent compiler warnings */
    ruleT__108Ex: ;

}
// $ANTLR end T__108

//   Comes from: 9:8: ( '[' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__109
 *
 * Looks to match the characters the constitute the token T__109
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__109(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__109;
       
    
    // IQL.g:9:8: ( '[' )
    // IQL.g:9:10: '['
    {
        MATCHC('['); 
        if  (HASEXCEPTION())
        {
            goto ruleT__109Ex;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__109Ex; /* Prevent compiler warnings */
    ruleT__109Ex: ;

}
// $ANTLR end T__109

//   Comes from: 10:8: ( ']' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__110
 *
 * Looks to match the characters the constitute the token T__110
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__110(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__110;
       
    
    // IQL.g:10:8: ( ']' )
    // IQL.g:10:10: ']'
    {
        MATCHC(']'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__110Ex;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__110Ex; /* Prevent compiler warnings */
    ruleT__110Ex: ;

}
// $ANTLR end T__110

//   Comes from: 11:8: ( ',' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__111
 *
 * Looks to match the characters the constitute the token T__111
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__111(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__111;
       
    
    // IQL.g:11:8: ( ',' )
    // IQL.g:11:10: ','
    {
        MATCHC(','); 
        if  (HASEXCEPTION())
        {
            goto ruleT__111Ex;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__111Ex; /* Prevent compiler warnings */
    ruleT__111Ex: ;

}
// $ANTLR end T__111

//   Comes from: 12:8: ( '->' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__112
 *
 * Looks to match the characters the constitute the token T__112
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__112(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__112;
       
    
    // IQL.g:12:8: ( '->' )
    // IQL.g:12:10: '->'
    {
        MATCHS(lit_1); 
        if  (HASEXCEPTION())
        {
            goto ruleT__112Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__112Ex; /* Prevent compiler warnings */
    ruleT__112Ex: ;

}
// $ANTLR end T__112

//   Comes from: 13:8: ( '.' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__113
 *
 * Looks to match the characters the constitute the token T__113
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__113(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__113;
       
    
    // IQL.g:13:8: ( '.' )
    // IQL.g:13:10: '.'
    {
        MATCHC('.'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__113Ex;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__113Ex; /* Prevent compiler warnings */
    ruleT__113Ex: ;

}
// $ANTLR end T__113

//   Comes from: 14:8: ( '*' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__114
 *
 * Looks to match the characters the constitute the token T__114
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__114(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__114;
       
    
    // IQL.g:14:8: ( '*' )
    // IQL.g:14:10: '*'
    {
        MATCHC('*'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__114Ex;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__114Ex; /* Prevent compiler warnings */
    ruleT__114Ex: ;

}
// $ANTLR end T__114

//   Comes from: 15:8: ( '(' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__115
 *
 * Looks to match the characters the constitute the token T__115
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__115(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__115;
       
    
    // IQL.g:15:8: ( '(' )
    // IQL.g:15:10: '('
    {
        MATCHC('('); 
        if  (HASEXCEPTION())
        {
            goto ruleT__115Ex;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__115Ex; /* Prevent compiler warnings */
    ruleT__115Ex: ;

}
// $ANTLR end T__115

//   Comes from: 16:8: ( ')' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__116
 *
 * Looks to match the characters the constitute the token T__116
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__116(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__116;
       
    
    // IQL.g:16:8: ( ')' )
    // IQL.g:16:10: ')'
    {
        MATCHC(')'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__116Ex;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__116Ex; /* Prevent compiler warnings */
    ruleT__116Ex: ;

}
// $ANTLR end T__116

//   Comes from: 17:8: ( '?' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__117
 *
 * Looks to match the characters the constitute the token T__117
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__117(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__117;
       
    
    // IQL.g:17:8: ( '?' )
    // IQL.g:17:10: '?'
    {
        MATCHC('?'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__117Ex;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__117Ex; /* Prevent compiler warnings */
    ruleT__117Ex: ;

}
// $ANTLR end T__117

//   Comes from: 18:8: ( ':' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__118
 *
 * Looks to match the characters the constitute the token T__118
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__118(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__118;
       
    
    // IQL.g:18:8: ( ':' )
    // IQL.g:18:10: ':'
    {
        MATCHC(':'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__118Ex;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__118Ex; /* Prevent compiler warnings */
    ruleT__118Ex: ;

}
// $ANTLR end T__118

//   Comes from: 19:8: ( '^' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__119
 *
 * Looks to match the characters the constitute the token T__119
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__119(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__119;
       
    
    // IQL.g:19:8: ( '^' )
    // IQL.g:19:10: '^'
    {
        MATCHC('^'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__119Ex;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__119Ex; /* Prevent compiler warnings */
    ruleT__119Ex: ;

}
// $ANTLR end T__119

//   Comes from: 20:8: ( '|' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__120
 *
 * Looks to match the characters the constitute the token T__120
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__120(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__120;
       
    
    // IQL.g:20:8: ( '|' )
    // IQL.g:20:10: '|'
    {
        MATCHC('|'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__120Ex;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__120Ex; /* Prevent compiler warnings */
    ruleT__120Ex: ;

}
// $ANTLR end T__120

//   Comes from: 21:8: ( '&' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__121
 *
 * Looks to match the characters the constitute the token T__121
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__121(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__121;
       
    
    // IQL.g:21:8: ( '&' )
    // IQL.g:21:10: '&'
    {
        MATCHC('&'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__121Ex;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__121Ex; /* Prevent compiler warnings */
    ruleT__121Ex: ;

}
// $ANTLR end T__121

//   Comes from: 22:8: ( '>' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__122
 *
 * Looks to match the characters the constitute the token T__122
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__122(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__122;
       
    
    // IQL.g:22:8: ( '>' )
    // IQL.g:22:10: '>'
    {
        MATCHC('>'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__122Ex;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__122Ex; /* Prevent compiler warnings */
    ruleT__122Ex: ;

}
// $ANTLR end T__122

//   Comes from: 23:8: ( '<' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__123
 *
 * Looks to match the characters the constitute the token T__123
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__123(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__123;
       
    
    // IQL.g:23:8: ( '<' )
    // IQL.g:23:10: '<'
    {
        MATCHC('<'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__123Ex;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__123Ex; /* Prevent compiler warnings */
    ruleT__123Ex: ;

}
// $ANTLR end T__123

//   Comes from: 24:8: ( '>=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__124
 *
 * Looks to match the characters the constitute the token T__124
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__124(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__124;
       
    
    // IQL.g:24:8: ( '>=' )
    // IQL.g:24:10: '>='
    {
        MATCHS(lit_2); 
        if  (HASEXCEPTION())
        {
            goto ruleT__124Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__124Ex; /* Prevent compiler warnings */
    ruleT__124Ex: ;

}
// $ANTLR end T__124

//   Comes from: 25:8: ( '<=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__125
 *
 * Looks to match the characters the constitute the token T__125
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__125(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__125;
       
    
    // IQL.g:25:8: ( '<=' )
    // IQL.g:25:10: '<='
    {
        MATCHS(lit_3); 
        if  (HASEXCEPTION())
        {
            goto ruleT__125Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__125Ex; /* Prevent compiler warnings */
    ruleT__125Ex: ;

}
// $ANTLR end T__125

//   Comes from: 26:8: ( '<>' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__126
 *
 * Looks to match the characters the constitute the token T__126
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__126(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__126;
       
    
    // IQL.g:26:8: ( '<>' )
    // IQL.g:26:10: '<>'
    {
        MATCHS(lit_4); 
        if  (HASEXCEPTION())
        {
            goto ruleT__126Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__126Ex; /* Prevent compiler warnings */
    ruleT__126Ex: ;

}
// $ANTLR end T__126

//   Comes from: 27:8: ( '+' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__127
 *
 * Looks to match the characters the constitute the token T__127
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__127(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__127;
       
    
    // IQL.g:27:8: ( '+' )
    // IQL.g:27:10: '+'
    {
        MATCHC('+'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__127Ex;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__127Ex; /* Prevent compiler warnings */
    ruleT__127Ex: ;

}
// $ANTLR end T__127

//   Comes from: 28:8: ( '-' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__128
 *
 * Looks to match the characters the constitute the token T__128
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__128(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__128;
       
    
    // IQL.g:28:8: ( '-' )
    // IQL.g:28:10: '-'
    {
        MATCHC('-'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__128Ex;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__128Ex; /* Prevent compiler warnings */
    ruleT__128Ex: ;

}
// $ANTLR end T__128

//   Comes from: 29:8: ( '/' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__129
 *
 * Looks to match the characters the constitute the token T__129
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__129(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__129;
       
    
    // IQL.g:29:8: ( '/' )
    // IQL.g:29:10: '/'
    {
        MATCHC('/'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__129Ex;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__129Ex; /* Prevent compiler warnings */
    ruleT__129Ex: ;

}
// $ANTLR end T__129

//   Comes from: 30:8: ( '%' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__130
 *
 * Looks to match the characters the constitute the token T__130
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__130(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__130;
       
    
    // IQL.g:30:8: ( '%' )
    // IQL.g:30:10: '%'
    {
        MATCHC('%'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__130Ex;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__130Ex; /* Prevent compiler warnings */
    ruleT__130Ex: ;

}
// $ANTLR end T__130

//   Comes from: 31:8: ( '~' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__131
 *
 * Looks to match the characters the constitute the token T__131
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__131(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__131;
       
    
    // IQL.g:31:8: ( '~' )
    // IQL.g:31:10: '~'
    {
        MATCHC('~'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__131Ex;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__131Ex; /* Prevent compiler warnings */
    ruleT__131Ex: ;

}
// $ANTLR end T__131

//   Comes from: 32:8: ( '#' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__132
 *
 * Looks to match the characters the constitute the token T__132
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__132(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__132;
       
    
    // IQL.g:32:8: ( '#' )
    // IQL.g:32:10: '#'
    {
        MATCHC('#'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__132Ex;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__132Ex; /* Prevent compiler warnings */
    ruleT__132Ex: ;

}
// $ANTLR end T__132

//   Comes from: 33:8: ( '$' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__133
 *
 * Looks to match the characters the constitute the token T__133
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__133(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__133;
       
    
    // IQL.g:33:8: ( '$' )
    // IQL.g:33:10: '$'
    {
        MATCHC('$'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__133Ex;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__133Ex; /* Prevent compiler warnings */
    ruleT__133Ex: ;

}
// $ANTLR end T__133

//   Comes from: 479:8: ( 'ADD' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_ADD
 *
 * Looks to match the characters the constitute the token TK_ADD
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_ADD(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_ADD;
       
    
    // IQL.g:479:8: ( 'ADD' )
    // IQL.g:479:10: 'ADD'
    {
        MATCHS(lit_5); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_ADDEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_ADDEx; /* Prevent compiler warnings */
    ruleTK_ADDEx: ;

}
// $ANTLR end TK_ADD

//   Comes from: 480:8: ( 'ALL' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_ALL
 *
 * Looks to match the characters the constitute the token TK_ALL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_ALL(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_ALL;
       
    
    // IQL.g:480:8: ( 'ALL' )
    // IQL.g:480:10: 'ALL'
    {
        MATCHS(lit_6); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_ALLEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_ALLEx; /* Prevent compiler warnings */
    ruleTK_ALLEx: ;

}
// $ANTLR end TK_ALL

//   Comes from: 481:10: ( 'ALTER' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_ALTER
 *
 * Looks to match the characters the constitute the token TK_ALTER
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_ALTER(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_ALTER;
       
    
    // IQL.g:481:10: ( 'ALTER' )
    // IQL.g:481:12: 'ALTER'
    {
        MATCHS(lit_7); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_ALTEREx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_ALTEREx; /* Prevent compiler warnings */
    ruleTK_ALTEREx: ;

}
// $ANTLR end TK_ALTER

//   Comes from: 482:8: ( 'AND' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_AND
 *
 * Looks to match the characters the constitute the token TK_AND
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_AND(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_AND;
       
    
    // IQL.g:482:8: ( 'AND' )
    // IQL.g:482:10: 'AND'
    {
        MATCHS(lit_8); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_ANDEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_ANDEx; /* Prevent compiler warnings */
    ruleTK_ANDEx: ;

}
// $ANTLR end TK_AND

//   Comes from: 483:8: ( 'ANY' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_ANY
 *
 * Looks to match the characters the constitute the token TK_ANY
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_ANY(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_ANY;
       
    
    // IQL.g:483:8: ( 'ANY' )
    // IQL.g:483:10: 'ANY'
    {
        MATCHS(lit_9); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_ANYEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_ANYEx; /* Prevent compiler warnings */
    ruleTK_ANYEx: ;

}
// $ANTLR end TK_ANY

//   Comes from: 484:7: ( 'AS' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_AS
 *
 * Looks to match the characters the constitute the token TK_AS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_AS(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_AS;
       
    
    // IQL.g:484:7: ( 'AS' )
    // IQL.g:484:9: 'AS'
    {
        MATCHS(lit_10); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_ASEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_ASEx; /* Prevent compiler warnings */
    ruleTK_ASEx: ;

}
// $ANTLR end TK_AS

//   Comes from: 485:8: ( 'ASC' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_ASC
 *
 * Looks to match the characters the constitute the token TK_ASC
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_ASC(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_ASC;
       
    
    // IQL.g:485:8: ( 'ASC' )
    // IQL.g:485:10: 'ASC'
    {
        MATCHS(lit_11); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_ASCEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_ASCEx; /* Prevent compiler warnings */
    ruleTK_ASCEx: ;

}
// $ANTLR end TK_ASC

//   Comes from: 486:8: ( 'AVG' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_AVG
 *
 * Looks to match the characters the constitute the token TK_AVG
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_AVG(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_AVG;
       
    
    // IQL.g:486:8: ( 'AVG' )
    // IQL.g:486:10: 'AVG'
    {
        MATCHS(lit_12); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_AVGEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_AVGEx; /* Prevent compiler warnings */
    ruleTK_AVGEx: ;

}
// $ANTLR end TK_AVG

//   Comes from: 487:10: ( 'BEGIN' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_BEGIN
 *
 * Looks to match the characters the constitute the token TK_BEGIN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_BEGIN(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_BEGIN;
       
    
    // IQL.g:487:10: ( 'BEGIN' )
    // IQL.g:487:12: 'BEGIN'
    {
        MATCHS(lit_13); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_BEGINEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_BEGINEx; /* Prevent compiler warnings */
    ruleTK_BEGINEx: ;

}
// $ANTLR end TK_BEGIN

//   Comes from: 488:12: ( 'BETWEEN' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_BETWEEN
 *
 * Looks to match the characters the constitute the token TK_BETWEEN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_BETWEEN(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_BETWEEN;
       
    
    // IQL.g:488:12: ( 'BETWEEN' )
    // IQL.g:488:14: 'BETWEEN'
    {
        MATCHS(lit_14); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_BETWEENEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_BETWEENEx; /* Prevent compiler warnings */
    ruleTK_BETWEENEx: ;

}
// $ANTLR end TK_BETWEEN

//   Comes from: 489:11: ( 'BIGINT' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_BIGINT
 *
 * Looks to match the characters the constitute the token TK_BIGINT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_BIGINT(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_BIGINT;
       
    
    // IQL.g:489:11: ( 'BIGINT' )
    // IQL.g:489:13: 'BIGINT'
    {
        MATCHS(lit_15); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_BIGINTEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_BIGINTEx; /* Prevent compiler warnings */
    ruleTK_BIGINTEx: ;

}
// $ANTLR end TK_BIGINT

//   Comes from: 490:12: ( 'BOOLEAN' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_BOOLEAN
 *
 * Looks to match the characters the constitute the token TK_BOOLEAN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_BOOLEAN(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_BOOLEAN;
       
    
    // IQL.g:490:12: ( 'BOOLEAN' )
    // IQL.g:490:14: 'BOOLEAN'
    {
        MATCHS(lit_16); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_BOOLEANEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_BOOLEANEx; /* Prevent compiler warnings */
    ruleTK_BOOLEANEx: ;

}
// $ANTLR end TK_BOOLEAN

//   Comes from: 491:10: ( 'BREAK' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_BREAK
 *
 * Looks to match the characters the constitute the token TK_BREAK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_BREAK(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_BREAK;
       
    
    // IQL.g:491:10: ( 'BREAK' )
    // IQL.g:491:12: 'BREAK'
    {
        MATCHS(lit_17); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_BREAKEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_BREAKEx; /* Prevent compiler warnings */
    ruleTK_BREAKEx: ;

}
// $ANTLR end TK_BREAK

//   Comes from: 492:7: ( 'BY' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_BY
 *
 * Looks to match the characters the constitute the token TK_BY
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_BY(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_BY;
       
    
    // IQL.g:492:7: ( 'BY' )
    // IQL.g:492:9: 'BY'
    {
        MATCHS(lit_18); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_BYEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_BYEx; /* Prevent compiler warnings */
    ruleTK_BYEx: ;

}
// $ANTLR end TK_BY

//   Comes from: 493:9: ( 'CASE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_CASE
 *
 * Looks to match the characters the constitute the token TK_CASE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_CASE(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_CASE;
       
    
    // IQL.g:493:9: ( 'CASE' )
    // IQL.g:493:11: 'CASE'
    {
        MATCHS(lit_19); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_CASEEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_CASEEx; /* Prevent compiler warnings */
    ruleTK_CASEEx: ;

}
// $ANTLR end TK_CASE

//   Comes from: 494:9: ( 'CAST' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_CAST
 *
 * Looks to match the characters the constitute the token TK_CAST
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_CAST(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_CAST;
       
    
    // IQL.g:494:9: ( 'CAST' )
    // IQL.g:494:11: 'CAST'
    {
        MATCHS(lit_20); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_CASTEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_CASTEx; /* Prevent compiler warnings */
    ruleTK_CASTEx: ;

}
// $ANTLR end TK_CAST

//   Comes from: 495:9: ( 'CHAR' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_CHAR
 *
 * Looks to match the characters the constitute the token TK_CHAR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_CHAR(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_CHAR;
       
    
    // IQL.g:495:9: ( 'CHAR' )
    // IQL.g:495:11: 'CHAR'
    {
        MATCHS(lit_21); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_CHAREx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_CHAREx; /* Prevent compiler warnings */
    ruleTK_CHAREx: ;

}
// $ANTLR end TK_CHAR

//   Comes from: 496:13: ( 'COALESCE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_COALESCE
 *
 * Looks to match the characters the constitute the token TK_COALESCE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_COALESCE(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_COALESCE;
       
    
    // IQL.g:496:13: ( 'COALESCE' )
    // IQL.g:496:15: 'COALESCE'
    {
        MATCHS(lit_22); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_COALESCEEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_COALESCEEx; /* Prevent compiler warnings */
    ruleTK_COALESCEEx: ;

}
// $ANTLR end TK_COALESCE

//   Comes from: 497:13: ( 'CONTINUE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_CONTINUE
 *
 * Looks to match the characters the constitute the token TK_CONTINUE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_CONTINUE(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_CONTINUE;
       
    
    // IQL.g:497:13: ( 'CONTINUE' )
    // IQL.g:497:15: 'CONTINUE'
    {
        MATCHS(lit_23); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_CONTINUEEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_CONTINUEEx; /* Prevent compiler warnings */
    ruleTK_CONTINUEEx: ;

}
// $ANTLR end TK_CONTINUE

//   Comes from: 498:10: ( 'COUNT' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_COUNT
 *
 * Looks to match the characters the constitute the token TK_COUNT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_COUNT(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_COUNT;
       
    
    // IQL.g:498:10: ( 'COUNT' )
    // IQL.g:498:12: 'COUNT'
    {
        MATCHS(lit_24); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_COUNTEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_COUNTEx; /* Prevent compiler warnings */
    ruleTK_COUNTEx: ;

}
// $ANTLR end TK_COUNT

//   Comes from: 499:11: ( 'CREATE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_CREATE
 *
 * Looks to match the characters the constitute the token TK_CREATE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_CREATE(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_CREATE;
       
    
    // IQL.g:499:11: ( 'CREATE' )
    // IQL.g:499:13: 'CREATE'
    {
        MATCHS(lit_25); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_CREATEEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_CREATEEx; /* Prevent compiler warnings */
    ruleTK_CREATEEx: ;

}
// $ANTLR end TK_CREATE

//   Comes from: 500:10: ( 'CROSS' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_CROSS
 *
 * Looks to match the characters the constitute the token TK_CROSS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_CROSS(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_CROSS;
       
    
    // IQL.g:500:10: ( 'CROSS' )
    // IQL.g:500:12: 'CROSS'
    {
        MATCHS(lit_26); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_CROSSEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_CROSSEx; /* Prevent compiler warnings */
    ruleTK_CROSSEx: ;

}
// $ANTLR end TK_CROSS

//   Comes from: 501:13: ( 'DATETIME' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_DATETIME
 *
 * Looks to match the characters the constitute the token TK_DATETIME
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_DATETIME(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_DATETIME;
       
    
    // IQL.g:501:13: ( 'DATETIME' )
    // IQL.g:501:15: 'DATETIME'
    {
        MATCHS(lit_27); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_DATETIMEEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_DATETIMEEx; /* Prevent compiler warnings */
    ruleTK_DATETIMEEx: ;

}
// $ANTLR end TK_DATETIME

//   Comes from: 502:12: ( 'DECLARE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_DECLARE
 *
 * Looks to match the characters the constitute the token TK_DECLARE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_DECLARE(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_DECLARE;
       
    
    // IQL.g:502:12: ( 'DECLARE' )
    // IQL.g:502:14: 'DECLARE'
    {
        MATCHS(lit_28); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_DECLAREEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_DECLAREEx; /* Prevent compiler warnings */
    ruleTK_DECLAREEx: ;

}
// $ANTLR end TK_DECLARE

//   Comes from: 503:12: ( 'DECIMAL' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_DECIMAL
 *
 * Looks to match the characters the constitute the token TK_DECIMAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_DECIMAL(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_DECIMAL;
       
    
    // IQL.g:503:12: ( 'DECIMAL' )
    // IQL.g:503:14: 'DECIMAL'
    {
        MATCHS(lit_29); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_DECIMALEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_DECIMALEx; /* Prevent compiler warnings */
    ruleTK_DECIMALEx: ;

}
// $ANTLR end TK_DECIMAL

//   Comes from: 504:9: ( 'DESC' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_DESC
 *
 * Looks to match the characters the constitute the token TK_DESC
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_DESC(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_DESC;
       
    
    // IQL.g:504:9: ( 'DESC' )
    // IQL.g:504:11: 'DESC'
    {
        MATCHS(lit_30); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_DESCEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_DESCEx; /* Prevent compiler warnings */
    ruleTK_DESCEx: ;

}
// $ANTLR end TK_DESC

//   Comes from: 505:13: ( 'DISTINCT' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_DISTINCT
 *
 * Looks to match the characters the constitute the token TK_DISTINCT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_DISTINCT(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_DISTINCT;
       
    
    // IQL.g:505:13: ( 'DISTINCT' )
    // IQL.g:505:15: 'DISTINCT'
    {
        MATCHS(lit_31); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_DISTINCTEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_DISTINCTEx; /* Prevent compiler warnings */
    ruleTK_DISTINCTEx: ;

}
// $ANTLR end TK_DISTINCT

//   Comes from: 506:11: ( 'DOUBLE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_DOUBLE
 *
 * Looks to match the characters the constitute the token TK_DOUBLE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_DOUBLE(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_DOUBLE;
       
    
    // IQL.g:506:11: ( 'DOUBLE' )
    // IQL.g:506:13: 'DOUBLE'
    {
        MATCHS(lit_32); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_DOUBLEEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_DOUBLEEx; /* Prevent compiler warnings */
    ruleTK_DOUBLEEx: ;

}
// $ANTLR end TK_DOUBLE

//   Comes from: 507:9: ( 'ELSE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_ELSE
 *
 * Looks to match the characters the constitute the token TK_ELSE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_ELSE(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_ELSE;
       
    
    // IQL.g:507:9: ( 'ELSE' )
    // IQL.g:507:11: 'ELSE'
    {
        MATCHS(lit_33); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_ELSEEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_ELSEEx; /* Prevent compiler warnings */
    ruleTK_ELSEEx: ;

}
// $ANTLR end TK_ELSE

//   Comes from: 508:8: ( 'END' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_END
 *
 * Looks to match the characters the constitute the token TK_END
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_END(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_END;
       
    
    // IQL.g:508:8: ( 'END' )
    // IQL.g:508:10: 'END'
    {
        MATCHS(lit_34); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_ENDEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_ENDEx; /* Prevent compiler warnings */
    ruleTK_ENDEx: ;

}
// $ANTLR end TK_END

//   Comes from: 509:11: ( 'EXISTS' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_EXISTS
 *
 * Looks to match the characters the constitute the token TK_EXISTS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_EXISTS(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_EXISTS;
       
    
    // IQL.g:509:11: ( 'EXISTS' )
    // IQL.g:509:13: 'EXISTS'
    {
        MATCHS(lit_35); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_EXISTSEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_EXISTSEx; /* Prevent compiler warnings */
    ruleTK_EXISTSEx: ;

}
// $ANTLR end TK_EXISTS

//   Comes from: 510:10: ( 'FALSE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_FALSE
 *
 * Looks to match the characters the constitute the token TK_FALSE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_FALSE(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_FALSE;
       
    
    // IQL.g:510:10: ( 'FALSE' )
    // IQL.g:510:12: 'FALSE'
    {
        MATCHS(lit_36); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_FALSEEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_FALSEEx; /* Prevent compiler warnings */
    ruleTK_FALSEEx: ;

}
// $ANTLR end TK_FALSE

//   Comes from: 511:9: ( 'FROM' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_FROM
 *
 * Looks to match the characters the constitute the token TK_FROM
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_FROM(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_FROM;
       
    
    // IQL.g:511:9: ( 'FROM' )
    // IQL.g:511:11: 'FROM'
    {
        MATCHS(lit_37); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_FROMEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_FROMEx; /* Prevent compiler warnings */
    ruleTK_FROMEx: ;

}
// $ANTLR end TK_FROM

//   Comes from: 512:9: ( 'FULL' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_FULL
 *
 * Looks to match the characters the constitute the token TK_FULL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_FULL(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_FULL;
       
    
    // IQL.g:512:9: ( 'FULL' )
    // IQL.g:512:11: 'FULL'
    {
        MATCHS(lit_38); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_FULLEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_FULLEx; /* Prevent compiler warnings */
    ruleTK_FULLEx: ;

}
// $ANTLR end TK_FULL

//   Comes from: 513:13: ( 'FUNCTION' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_FUNCTION
 *
 * Looks to match the characters the constitute the token TK_FUNCTION
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_FUNCTION(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_FUNCTION;
       
    
    // IQL.g:513:13: ( 'FUNCTION' )
    // IQL.g:513:15: 'FUNCTION'
    {
        MATCHS(lit_39); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_FUNCTIONEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_FUNCTIONEx; /* Prevent compiler warnings */
    ruleTK_FUNCTIONEx: ;

}
// $ANTLR end TK_FUNCTION

//   Comes from: 514:10: ( 'GROUP' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_GROUP
 *
 * Looks to match the characters the constitute the token TK_GROUP
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_GROUP(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_GROUP;
       
    
    // IQL.g:514:10: ( 'GROUP' )
    // IQL.g:514:12: 'GROUP'
    {
        MATCHS(lit_40); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_GROUPEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_GROUPEx; /* Prevent compiler warnings */
    ruleTK_GROUPEx: ;

}
// $ANTLR end TK_GROUP

//   Comes from: 515:11: ( 'HAVING' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_HAVING
 *
 * Looks to match the characters the constitute the token TK_HAVING
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_HAVING(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_HAVING;
       
    
    // IQL.g:515:11: ( 'HAVING' )
    // IQL.g:515:13: 'HAVING'
    {
        MATCHS(lit_41); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_HAVINGEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_HAVINGEx; /* Prevent compiler warnings */
    ruleTK_HAVINGEx: ;

}
// $ANTLR end TK_HAVING

//   Comes from: 516:7: ( 'IF' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_IF
 *
 * Looks to match the characters the constitute the token TK_IF
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_IF(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_IF;
       
    
    // IQL.g:516:7: ( 'IF' )
    // IQL.g:516:9: 'IF'
    {
        MATCHS(lit_42); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_IFEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_IFEx; /* Prevent compiler warnings */
    ruleTK_IFEx: ;

}
// $ANTLR end TK_IF

//   Comes from: 517:7: ( 'IN' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_IN
 *
 * Looks to match the characters the constitute the token TK_IN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_IN(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_IN;
       
    
    // IQL.g:517:7: ( 'IN' )
    // IQL.g:517:9: 'IN'
    {
        MATCHS(lit_43); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_INEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_INEx; /* Prevent compiler warnings */
    ruleTK_INEx: ;

}
// $ANTLR end TK_IN

//   Comes from: 518:10: ( 'INDEX' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_INDEX
 *
 * Looks to match the characters the constitute the token TK_INDEX
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_INDEX(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_INDEX;
       
    
    // IQL.g:518:10: ( 'INDEX' )
    // IQL.g:518:12: 'INDEX'
    {
        MATCHS(lit_44); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_INDEXEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_INDEXEx; /* Prevent compiler warnings */
    ruleTK_INDEXEx: ;

}
// $ANTLR end TK_INDEX

//   Comes from: 519:10: ( 'INNER' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_INNER
 *
 * Looks to match the characters the constitute the token TK_INNER
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_INNER(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_INNER;
       
    
    // IQL.g:519:10: ( 'INNER' )
    // IQL.g:519:12: 'INNER'
    {
        MATCHS(lit_45); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_INNEREx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_INNEREx; /* Prevent compiler warnings */
    ruleTK_INNEREx: ;

}
// $ANTLR end TK_INNER

//   Comes from: 520:9: ( 'INTO' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_INTO
 *
 * Looks to match the characters the constitute the token TK_INTO
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_INTO(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_INTO;
       
    
    // IQL.g:520:9: ( 'INTO' )
    // IQL.g:520:11: 'INTO'
    {
        MATCHS(lit_46); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_INTOEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_INTOEx; /* Prevent compiler warnings */
    ruleTK_INTOEx: ;

}
// $ANTLR end TK_INTO

//   Comes from: 521:12: ( 'INTEGER' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_INTEGER
 *
 * Looks to match the characters the constitute the token TK_INTEGER
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_INTEGER(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_INTEGER;
       
    
    // IQL.g:521:12: ( 'INTEGER' )
    // IQL.g:521:14: 'INTEGER'
    {
        MATCHS(lit_47); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_INTEGEREx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_INTEGEREx; /* Prevent compiler warnings */
    ruleTK_INTEGEREx: ;

}
// $ANTLR end TK_INTEGER

//   Comes from: 522:13: ( 'INTERVAL' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_INTERVAL
 *
 * Looks to match the characters the constitute the token TK_INTERVAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_INTERVAL(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_INTERVAL;
       
    
    // IQL.g:522:13: ( 'INTERVAL' )
    // IQL.g:522:15: 'INTERVAL'
    {
        MATCHS(lit_48); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_INTERVALEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_INTERVALEx; /* Prevent compiler warnings */
    ruleTK_INTERVALEx: ;

}
// $ANTLR end TK_INTERVAL

//   Comes from: 523:7: ( 'IS' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_IS
 *
 * Looks to match the characters the constitute the token TK_IS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_IS(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_IS;
       
    
    // IQL.g:523:7: ( 'IS' )
    // IQL.g:523:9: 'IS'
    {
        MATCHS(lit_49); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_ISEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_ISEx; /* Prevent compiler warnings */
    ruleTK_ISEx: ;

}
// $ANTLR end TK_IS

//   Comes from: 524:9: ( 'JOIN' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_JOIN
 *
 * Looks to match the characters the constitute the token TK_JOIN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_JOIN(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_JOIN;
       
    
    // IQL.g:524:9: ( 'JOIN' )
    // IQL.g:524:11: 'JOIN'
    {
        MATCHS(lit_50); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_JOINEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_JOINEx; /* Prevent compiler warnings */
    ruleTK_JOINEx: ;

}
// $ANTLR end TK_JOIN

//   Comes from: 525:8: ( 'KEY' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_KEY
 *
 * Looks to match the characters the constitute the token TK_KEY
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_KEY(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_KEY;
       
    
    // IQL.g:525:8: ( 'KEY' )
    // IQL.g:525:10: 'KEY'
    {
        MATCHS(lit_51); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_KEYEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_KEYEx; /* Prevent compiler warnings */
    ruleTK_KEYEx: ;

}
// $ANTLR end TK_KEY

//   Comes from: 526:9: ( 'LEFT' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_LEFT
 *
 * Looks to match the characters the constitute the token TK_LEFT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_LEFT(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_LEFT;
       
    
    // IQL.g:526:9: ( 'LEFT' )
    // IQL.g:526:11: 'LEFT'
    {
        MATCHS(lit_52); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_LEFTEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_LEFTEx; /* Prevent compiler warnings */
    ruleTK_LEFTEx: ;

}
// $ANTLR end TK_LEFT

//   Comes from: 527:9: ( 'LIKE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_LIKE
 *
 * Looks to match the characters the constitute the token TK_LIKE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_LIKE(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_LIKE;
       
    
    // IQL.g:527:9: ( 'LIKE' )
    // IQL.g:527:11: 'LIKE'
    {
        MATCHS(lit_53); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_LIKEEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_LIKEEx; /* Prevent compiler warnings */
    ruleTK_LIKEEx: ;

}
// $ANTLR end TK_LIKE

//   Comes from: 528:8: ( 'MAX' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_MAX
 *
 * Looks to match the characters the constitute the token TK_MAX
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_MAX(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_MAX;
       
    
    // IQL.g:528:8: ( 'MAX' )
    // IQL.g:528:10: 'MAX'
    {
        MATCHS(lit_54); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_MAXEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_MAXEx; /* Prevent compiler warnings */
    ruleTK_MAXEx: ;

}
// $ANTLR end TK_MAX

//   Comes from: 529:8: ( 'MIN' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_MIN
 *
 * Looks to match the characters the constitute the token TK_MIN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_MIN(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_MIN;
       
    
    // IQL.g:529:8: ( 'MIN' )
    // IQL.g:529:10: 'MIN'
    {
        MATCHS(lit_55); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_MINEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_MINEx; /* Prevent compiler warnings */
    ruleTK_MINEx: ;

}
// $ANTLR end TK_MIN

//   Comes from: 530:8: ( 'NOT' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_NOT
 *
 * Looks to match the characters the constitute the token TK_NOT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_NOT(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_NOT;
       
    
    // IQL.g:530:8: ( 'NOT' )
    // IQL.g:530:10: 'NOT'
    {
        MATCHS(lit_56); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_NOTEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_NOTEx; /* Prevent compiler warnings */
    ruleTK_NOTEx: ;

}
// $ANTLR end TK_NOT

//   Comes from: 531:9: ( 'NULL' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_NULL
 *
 * Looks to match the characters the constitute the token TK_NULL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_NULL(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_NULL;
       
    
    // IQL.g:531:9: ( 'NULL' )
    // IQL.g:531:11: 'NULL'
    {
        MATCHS(lit_57); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_NULLEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_NULLEx; /* Prevent compiler warnings */
    ruleTK_NULLEx: ;

}
// $ANTLR end TK_NULL

//   Comes from: 532:13: ( 'NVARCHAR' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_NVARCHAR
 *
 * Looks to match the characters the constitute the token TK_NVARCHAR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_NVARCHAR(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_NVARCHAR;
       
    
    // IQL.g:532:13: ( 'NVARCHAR' )
    // IQL.g:532:15: 'NVARCHAR'
    {
        MATCHS(lit_58); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_NVARCHAREx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_NVARCHAREx; /* Prevent compiler warnings */
    ruleTK_NVARCHAREx: ;

}
// $ANTLR end TK_NVARCHAR

//   Comes from: 533:7: ( 'ON' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_ON
 *
 * Looks to match the characters the constitute the token TK_ON
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_ON(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_ON;
       
    
    // IQL.g:533:7: ( 'ON' )
    // IQL.g:533:9: 'ON'
    {
        MATCHS(lit_59); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_ONEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_ONEx; /* Prevent compiler warnings */
    ruleTK_ONEx: ;

}
// $ANTLR end TK_ON

//   Comes from: 534:7: ( 'OR' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_OR
 *
 * Looks to match the characters the constitute the token TK_OR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_OR(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_OR;
       
    
    // IQL.g:534:7: ( 'OR' )
    // IQL.g:534:9: 'OR'
    {
        MATCHS(lit_60); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_OREx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_OREx; /* Prevent compiler warnings */
    ruleTK_OREx: ;

}
// $ANTLR end TK_OR

//   Comes from: 535:10: ( 'ORDER' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_ORDER
 *
 * Looks to match the characters the constitute the token TK_ORDER
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_ORDER(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_ORDER;
       
    
    // IQL.g:535:10: ( 'ORDER' )
    // IQL.g:535:12: 'ORDER'
    {
        MATCHS(lit_61); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_ORDEREx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_ORDEREx; /* Prevent compiler warnings */
    ruleTK_ORDEREx: ;

}
// $ANTLR end TK_ORDER

//   Comes from: 536:10: ( 'OUTER' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_OUTER
 *
 * Looks to match the characters the constitute the token TK_OUTER
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_OUTER(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_OUTER;
       
    
    // IQL.g:536:10: ( 'OUTER' )
    // IQL.g:536:12: 'OUTER'
    {
        MATCHS(lit_62); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_OUTEREx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_OUTEREx; /* Prevent compiler warnings */
    ruleTK_OUTEREx: ;

}
// $ANTLR end TK_OUTER

//   Comes from: 537:11: ( 'OUTPUT' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_OUTPUT
 *
 * Looks to match the characters the constitute the token TK_OUTPUT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_OUTPUT(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_OUTPUT;
       
    
    // IQL.g:537:11: ( 'OUTPUT' )
    // IQL.g:537:13: 'OUTPUT'
    {
        MATCHS(lit_63); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_OUTPUTEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_OUTPUTEx; /* Prevent compiler warnings */
    ruleTK_OUTPUTEx: ;

}
// $ANTLR end TK_OUTPUT

//   Comes from: 538:14: ( 'PRECISION' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_PRECISION
 *
 * Looks to match the characters the constitute the token TK_PRECISION
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_PRECISION(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_PRECISION;
       
    
    // IQL.g:538:14: ( 'PRECISION' )
    // IQL.g:538:16: 'PRECISION'
    {
        MATCHS(lit_64); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_PRECISIONEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_PRECISIONEx; /* Prevent compiler warnings */
    ruleTK_PRECISIONEx: ;

}
// $ANTLR end TK_PRECISION

//   Comes from: 539:10: ( 'PRINT' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_PRINT
 *
 * Looks to match the characters the constitute the token TK_PRINT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_PRINT(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_PRINT;
       
    
    // IQL.g:539:10: ( 'PRINT' )
    // IQL.g:539:12: 'PRINT'
    {
        MATCHS(lit_65); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_PRINTEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_PRINTEx; /* Prevent compiler warnings */
    ruleTK_PRINTEx: ;

}
// $ANTLR end TK_PRINT

//   Comes from: 540:14: ( 'PROCEDURE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_PROCEDURE
 *
 * Looks to match the characters the constitute the token TK_PROCEDURE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_PROCEDURE(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_PROCEDURE;
       
    
    // IQL.g:540:14: ( 'PROCEDURE' )
    // IQL.g:540:16: 'PROCEDURE'
    {
        MATCHS(lit_66); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_PROCEDUREEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_PROCEDUREEx; /* Prevent compiler warnings */
    ruleTK_PROCEDUREEx: ;

}
// $ANTLR end TK_PROCEDURE

//   Comes from: 541:14: ( 'RAISERROR' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_RAISERROR
 *
 * Looks to match the characters the constitute the token TK_RAISERROR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_RAISERROR(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_RAISERROR;
       
    
    // IQL.g:541:14: ( 'RAISERROR' )
    // IQL.g:541:16: 'RAISERROR'
    {
        MATCHS(lit_67); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_RAISERROREx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_RAISERROREx; /* Prevent compiler warnings */
    ruleTK_RAISERROREx: ;

}
// $ANTLR end TK_RAISERROR

//   Comes from: 542:11: ( 'RETURN' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_RETURN
 *
 * Looks to match the characters the constitute the token TK_RETURN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_RETURN(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_RETURN;
       
    
    // IQL.g:542:11: ( 'RETURN' )
    // IQL.g:542:13: 'RETURN'
    {
        MATCHS(lit_68); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_RETURNEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_RETURNEx; /* Prevent compiler warnings */
    ruleTK_RETURNEx: ;

}
// $ANTLR end TK_RETURN

//   Comes from: 543:12: ( 'RETURNS' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_RETURNS
 *
 * Looks to match the characters the constitute the token TK_RETURNS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_RETURNS(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_RETURNS;
       
    
    // IQL.g:543:12: ( 'RETURNS' )
    // IQL.g:543:14: 'RETURNS'
    {
        MATCHS(lit_69); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_RETURNSEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_RETURNSEx; /* Prevent compiler warnings */
    ruleTK_RETURNSEx: ;

}
// $ANTLR end TK_RETURNS

//   Comes from: 544:10: ( 'RIGHT' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_RIGHT
 *
 * Looks to match the characters the constitute the token TK_RIGHT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_RIGHT(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_RIGHT;
       
    
    // IQL.g:544:10: ( 'RIGHT' )
    // IQL.g:544:12: 'RIGHT'
    {
        MATCHS(lit_70); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_RIGHTEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_RIGHTEx; /* Prevent compiler warnings */
    ruleTK_RIGHTEx: ;

}
// $ANTLR end TK_RIGHT

//   Comes from: 545:10: ( 'RLIKE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_RLIKE
 *
 * Looks to match the characters the constitute the token TK_RLIKE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_RLIKE(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_RLIKE;
       
    
    // IQL.g:545:10: ( 'RLIKE' )
    // IQL.g:545:12: 'RLIKE'
    {
        MATCHS(lit_71); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_RLIKEEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_RLIKEEx; /* Prevent compiler warnings */
    ruleTK_RLIKEEx: ;

}
// $ANTLR end TK_RLIKE

//   Comes from: 546:11: ( 'SELECT' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_SELECT
 *
 * Looks to match the characters the constitute the token TK_SELECT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_SELECT(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_SELECT;
       
    
    // IQL.g:546:11: ( 'SELECT' )
    // IQL.g:546:13: 'SELECT'
    {
        MATCHS(lit_72); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_SELECTEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_SELECTEx; /* Prevent compiler warnings */
    ruleTK_SELECTEx: ;

}
// $ANTLR end TK_SELECT

//   Comes from: 547:8: ( 'SET' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_SET
 *
 * Looks to match the characters the constitute the token TK_SET
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_SET(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_SET;
       
    
    // IQL.g:547:8: ( 'SET' )
    // IQL.g:547:10: 'SET'
    {
        MATCHS(lit_73); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_SETEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_SETEx; /* Prevent compiler warnings */
    ruleTK_SETEx: ;

}
// $ANTLR end TK_SET

//   Comes from: 548:9: ( 'SOME' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_SOME
 *
 * Looks to match the characters the constitute the token TK_SOME
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_SOME(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_SOME;
       
    
    // IQL.g:548:9: ( 'SOME' )
    // IQL.g:548:11: 'SOME'
    {
        MATCHS(lit_74); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_SOMEEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_SOMEEx; /* Prevent compiler warnings */
    ruleTK_SOMEEx: ;

}
// $ANTLR end TK_SOME

//   Comes from: 549:8: ( 'SUM' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_SUM
 *
 * Looks to match the characters the constitute the token TK_SUM
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_SUM(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_SUM;
       
    
    // IQL.g:549:8: ( 'SUM' )
    // IQL.g:549:10: 'SUM'
    {
        MATCHS(lit_75); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_SUMEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_SUMEx; /* Prevent compiler warnings */
    ruleTK_SUMEx: ;

}
// $ANTLR end TK_SUM

//   Comes from: 550:11: ( 'SWITCH' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_SWITCH
 *
 * Looks to match the characters the constitute the token TK_SWITCH
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_SWITCH(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_SWITCH;
       
    
    // IQL.g:550:11: ( 'SWITCH' )
    // IQL.g:550:13: 'SWITCH'
    {
        MATCHS(lit_76); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_SWITCHEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_SWITCHEx; /* Prevent compiler warnings */
    ruleTK_SWITCHEx: ;

}
// $ANTLR end TK_SWITCH

//   Comes from: 551:9: ( 'THEN' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_THEN
 *
 * Looks to match the characters the constitute the token TK_THEN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_THEN(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_THEN;
       
    
    // IQL.g:551:9: ( 'THEN' )
    // IQL.g:551:11: 'THEN'
    {
        MATCHS(lit_77); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_THENEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_THENEx; /* Prevent compiler warnings */
    ruleTK_THENEx: ;

}
// $ANTLR end TK_THEN

//   Comes from: 552:9: ( 'TRUE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_TRUE
 *
 * Looks to match the characters the constitute the token TK_TRUE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_TRUE(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_TRUE;
       
    
    // IQL.g:552:9: ( 'TRUE' )
    // IQL.g:552:11: 'TRUE'
    {
        MATCHS(lit_78); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_TRUEEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_TRUEEx; /* Prevent compiler warnings */
    ruleTK_TRUEEx: ;

}
// $ANTLR end TK_TRUE

//   Comes from: 553:10: ( 'UNION' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_UNION
 *
 * Looks to match the characters the constitute the token TK_UNION
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_UNION(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_UNION;
       
    
    // IQL.g:553:10: ( 'UNION' )
    // IQL.g:553:12: 'UNION'
    {
        MATCHS(lit_79); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_UNIONEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_UNIONEx; /* Prevent compiler warnings */
    ruleTK_UNIONEx: ;

}
// $ANTLR end TK_UNION

//   Comes from: 554:12: ( 'VARCHAR' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_VARCHAR
 *
 * Looks to match the characters the constitute the token TK_VARCHAR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_VARCHAR(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_VARCHAR;
       
    
    // IQL.g:554:12: ( 'VARCHAR' )
    // IQL.g:554:14: 'VARCHAR'
    {
        MATCHS(lit_80); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_VARCHAREx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_VARCHAREx; /* Prevent compiler warnings */
    ruleTK_VARCHAREx: ;

}
// $ANTLR end TK_VARCHAR

//   Comes from: 555:9: ( 'WHEN' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_WHEN
 *
 * Looks to match the characters the constitute the token TK_WHEN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_WHEN(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_WHEN;
       
    
    // IQL.g:555:9: ( 'WHEN' )
    // IQL.g:555:11: 'WHEN'
    {
        MATCHS(lit_81); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_WHENEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_WHENEx; /* Prevent compiler warnings */
    ruleTK_WHENEx: ;

}
// $ANTLR end TK_WHEN

//   Comes from: 556:10: ( 'WHERE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_WHERE
 *
 * Looks to match the characters the constitute the token TK_WHERE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_WHERE(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_WHERE;
       
    
    // IQL.g:556:10: ( 'WHERE' )
    // IQL.g:556:12: 'WHERE'
    {
        MATCHS(lit_82); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_WHEREEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_WHEREEx; /* Prevent compiler warnings */
    ruleTK_WHEREEx: ;

}
// $ANTLR end TK_WHERE

//   Comes from: 557:10: ( 'WHILE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_WHILE
 *
 * Looks to match the characters the constitute the token TK_WHILE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_WHILE(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_WHILE;
       
    
    // IQL.g:557:10: ( 'WHILE' )
    // IQL.g:557:12: 'WHILE'
    {
        MATCHS(lit_83); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_WHILEEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_WHILEEx; /* Prevent compiler warnings */
    ruleTK_WHILEEx: ;

}
// $ANTLR end TK_WHILE

//   Comes from: 558:9: ( 'WITH' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TK_WITH
 *
 * Looks to match the characters the constitute the token TK_WITH
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTK_WITH(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TK_WITH;
       
    
    // IQL.g:558:9: ( 'WITH' )
    // IQL.g:558:11: 'WITH'
    {
        MATCHS(lit_84); 
        if  (HASEXCEPTION())
        {
            goto ruleTK_WITHEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTK_WITHEx; /* Prevent compiler warnings */
    ruleTK_WITHEx: ;

}
// $ANTLR end TK_WITH

//   Comes from: 561:5: ( '\\'' ( ESCAPE_SEQUENCE | ~ ( '\\\\' | '\\'' ) )* '\\'' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start STRING_LITERAL
 *
 * Looks to match the characters the constitute the token STRING_LITERAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSTRING_LITERAL(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = STRING_LITERAL;
       
    
    // IQL.g:561:5: ( '\\'' ( ESCAPE_SEQUENCE | ~ ( '\\\\' | '\\'' ) )* '\\'' )
    // IQL.g:561:8: '\\'' ( ESCAPE_SEQUENCE | ~ ( '\\\\' | '\\'' ) )* '\\''
    {
        MATCHC('\''); 
        if  (HASEXCEPTION())
        {
            goto ruleSTRING_LITERALEx;
        }


        // IQL.g:561:13: ( ESCAPE_SEQUENCE | ~ ( '\\\\' | '\\'' ) )*

        for (;;)
        {
            int alt1=3;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA1_0 = LA(1);
                if ( (LA1_0 == '\\') ) 
                {
                    alt1=1;
                }
                else if ( (((LA1_0 >= 0x0000) && (LA1_0 <= '&')) || ((LA1_0 >= '(') && (LA1_0 <= '[')) || ((LA1_0 >= ']') && (LA1_0 <= 0xFFFF))) ) 
                {
                    alt1=2;
                }

            }
            switch (alt1) 
            {
        	case 1:
        	    // IQL.g:561:15: ESCAPE_SEQUENCE
        	    {
        	        /* 561:15: ESCAPE_SEQUENCE */
        	        mESCAPE_SEQUENCE(ctx ); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleSTRING_LITERALEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // IQL.g:561:33: ~ ( '\\\\' | '\\'' )
        	    {
        	        if ( ((LA(1) >= 0x0000) && (LA(1) <= '&')) || ((LA(1) >= '(') && (LA(1) <= '[')) || ((LA(1) >= ']') && (LA(1) <= 0xFFFF)) )
        	        {
        	            CONSUME();

        	        }
        	        else 
        	        {
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	            LRECOVER();    goto ruleSTRING_LITERALEx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop1;	/* break out of the loop */
        	    break;
            }
        }
        loop1: ; /* Jump out to here if this rule does not match */

        MATCHC('\''); 
        if  (HASEXCEPTION())
        {
            goto ruleSTRING_LITERALEx;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleSTRING_LITERALEx; /* Prevent compiler warnings */
    ruleSTRING_LITERALEx: ;

}
// $ANTLR end STRING_LITERAL

//   Comes from: 565:5: ( 'N\\'' ( ESCAPE_SEQUENCE | ~ ( '\\\\' | '\\'' ) )* '\\'' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start WSTRING_LITERAL
 *
 * Looks to match the characters the constitute the token WSTRING_LITERAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mWSTRING_LITERAL(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = WSTRING_LITERAL;
       
    
    // IQL.g:565:5: ( 'N\\'' ( ESCAPE_SEQUENCE | ~ ( '\\\\' | '\\'' ) )* '\\'' )
    // IQL.g:565:8: 'N\\'' ( ESCAPE_SEQUENCE | ~ ( '\\\\' | '\\'' ) )* '\\''
    {
        MATCHS(lit_85); 
        if  (HASEXCEPTION())
        {
            goto ruleWSTRING_LITERALEx;
        }



        // IQL.g:565:14: ( ESCAPE_SEQUENCE | ~ ( '\\\\' | '\\'' ) )*

        for (;;)
        {
            int alt2=3;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA2_0 = LA(1);
                if ( (LA2_0 == '\\') ) 
                {
                    alt2=1;
                }
                else if ( (((LA2_0 >= 0x0000) && (LA2_0 <= '&')) || ((LA2_0 >= '(') && (LA2_0 <= '[')) || ((LA2_0 >= ']') && (LA2_0 <= 0xFFFF))) ) 
                {
                    alt2=2;
                }

            }
            switch (alt2) 
            {
        	case 1:
        	    // IQL.g:565:16: ESCAPE_SEQUENCE
        	    {
        	        /* 565:16: ESCAPE_SEQUENCE */
        	        mESCAPE_SEQUENCE(ctx ); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleWSTRING_LITERALEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // IQL.g:565:34: ~ ( '\\\\' | '\\'' )
        	    {
        	        if ( ((LA(1) >= 0x0000) && (LA(1) <= '&')) || ((LA(1) >= '(') && (LA(1) <= '[')) || ((LA(1) >= ']') && (LA(1) <= 0xFFFF)) )
        	        {
        	            CONSUME();

        	        }
        	        else 
        	        {
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	            LRECOVER();    goto ruleWSTRING_LITERALEx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop2;	/* break out of the loop */
        	    break;
            }
        }
        loop2: ; /* Jump out to here if this rule does not match */

        MATCHC('\''); 
        if  (HASEXCEPTION())
        {
            goto ruleWSTRING_LITERALEx;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleWSTRING_LITERALEx; /* Prevent compiler warnings */
    ruleWSTRING_LITERALEx: ;

}
// $ANTLR end WSTRING_LITERAL

//   Comes from: 569:5: ( '\"' ( ESCAPE_SEQUENCE | ~ ( '\\\\' | '\"' ) )* '\"' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DOUBLE_QUOTED_STRING_LITERAL
 *
 * Looks to match the characters the constitute the token DOUBLE_QUOTED_STRING_LITERAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mDOUBLE_QUOTED_STRING_LITERAL(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = DOUBLE_QUOTED_STRING_LITERAL;
       
    
    // IQL.g:569:5: ( '\"' ( ESCAPE_SEQUENCE | ~ ( '\\\\' | '\"' ) )* '\"' )
    // IQL.g:569:8: '\"' ( ESCAPE_SEQUENCE | ~ ( '\\\\' | '\"' ) )* '\"'
    {
        MATCHC('"'); 
        if  (HASEXCEPTION())
        {
            goto ruleDOUBLE_QUOTED_STRING_LITERALEx;
        }


        // IQL.g:569:12: ( ESCAPE_SEQUENCE | ~ ( '\\\\' | '\"' ) )*

        for (;;)
        {
            int alt3=3;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA3_0 = LA(1);
                if ( (LA3_0 == '\\') ) 
                {
                    alt3=1;
                }
                else if ( (((LA3_0 >= 0x0000) && (LA3_0 <= '!')) || ((LA3_0 >= '#') && (LA3_0 <= '[')) || ((LA3_0 >= ']') && (LA3_0 <= 0xFFFF))) ) 
                {
                    alt3=2;
                }

            }
            switch (alt3) 
            {
        	case 1:
        	    // IQL.g:569:14: ESCAPE_SEQUENCE
        	    {
        	        /* 569:14: ESCAPE_SEQUENCE */
        	        mESCAPE_SEQUENCE(ctx ); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleDOUBLE_QUOTED_STRING_LITERALEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // IQL.g:569:32: ~ ( '\\\\' | '\"' )
        	    {
        	        if ( ((LA(1) >= 0x0000) && (LA(1) <= '!')) || ((LA(1) >= '#') && (LA(1) <= '[')) || ((LA(1) >= ']') && (LA(1) <= 0xFFFF)) )
        	        {
        	            CONSUME();

        	        }
        	        else 
        	        {
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	            LRECOVER();    goto ruleDOUBLE_QUOTED_STRING_LITERALEx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop3;	/* break out of the loop */
        	    break;
            }
        }
        loop3: ; /* Jump out to here if this rule does not match */

        MATCHC('"'); 
        if  (HASEXCEPTION())
        {
            goto ruleDOUBLE_QUOTED_STRING_LITERALEx;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleDOUBLE_QUOTED_STRING_LITERALEx; /* Prevent compiler warnings */
    ruleDOUBLE_QUOTED_STRING_LITERALEx: ;

}
// $ANTLR end DOUBLE_QUOTED_STRING_LITERAL

//   Comes from: 574:5: ( '\\\\' ( 'b' | 't' | 'n' | 'f' | 'r' | '\\\"' | '\\'' | '\\\\' ) | UNICODE_ESCAPE | OCTAL_ESCAPE )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ESCAPE_SEQUENCE
 *
 * Looks to match the characters the constitute the token ESCAPE_SEQUENCE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mESCAPE_SEQUENCE(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    {
        //  IQL.g:574:5: ( '\\\\' ( 'b' | 't' | 'n' | 'f' | 'r' | '\\\"' | '\\'' | '\\\\' ) | UNICODE_ESCAPE | OCTAL_ESCAPE )
        
        ANTLR3_UINT32 alt4;

        alt4=3;

        switch ( LA(1) ) 
        {
        case '\\':
        	{
        		switch ( LA(2) ) 
        		{
        		case '"':
        		case '\'':
        		case '\\':
        		case 'b':
        		case 'f':
        		case 'n':
        		case 'r':
        		case 't':
        			{
        				alt4=1;
        			}
        		    break;
        		case 'u':
        			{
        				alt4=2;
        			}
        		    break;
        		case '0':
        		case '1':
        		case '2':
        		case '3':
        		case '4':
        		case '5':
        		case '6':
        		case '7':
        			{
        				alt4=3;
        			}
        		    break;

        		default:
        		    CONSTRUCTEX();
        		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        		    EXCEPTION->message      = (void *)"";
        		    EXCEPTION->decisionNum  = 4;
        		    EXCEPTION->state        = 1;


        		    goto ruleESCAPE_SEQUENCEEx;
        		}

        	}
            break;

        default:
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            EXCEPTION->message      = (void *)"";
            EXCEPTION->decisionNum  = 4;
            EXCEPTION->state        = 0;


            goto ruleESCAPE_SEQUENCEEx;
        }

        switch (alt4) 
        {
    	case 1:
    	    // IQL.g:574:9: '\\\\' ( 'b' | 't' | 'n' | 'f' | 'r' | '\\\"' | '\\'' | '\\\\' )
    	    {
    	        MATCHC('\\'); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleESCAPE_SEQUENCEEx;
    	        }

    	        if ( LA(1) == '"' || LA(1) == '\'' || LA(1) == '\\' || LA(1) == 'b' || LA(1) == 'f' || LA(1) == 'n' || LA(1) == 'r' || LA(1) == 't' )
    	        {
    	            CONSUME();

    	        }
    	        else 
    	        {
    	            CONSTRUCTEX();
    	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
    	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

    	            LRECOVER();    goto ruleESCAPE_SEQUENCEEx;
    	        }


    	    }
    	    break;
    	case 2:
    	    // IQL.g:575:9: UNICODE_ESCAPE
    	    {
    	        /* 575:9: UNICODE_ESCAPE */
    	        mUNICODE_ESCAPE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleESCAPE_SEQUENCEEx;
    	        }


    	    }
    	    break;
    	case 3:
    	    // IQL.g:576:9: OCTAL_ESCAPE
    	    {
    	        /* 576:9: OCTAL_ESCAPE */
    	        mOCTAL_ESCAPE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleESCAPE_SEQUENCEEx;
    	        }


    	    }
    	    break;

        }
    }


    // This is where rules clean up and exit
    //
    goto ruleESCAPE_SEQUENCEEx; /* Prevent compiler warnings */
    ruleESCAPE_SEQUENCEEx: ;

}
// $ANTLR end ESCAPE_SEQUENCE

//   Comes from: 581:5: ( '\\\\' ( '0' .. '3' ) ( '0' .. '7' ) ( '0' .. '7' ) | '\\\\' ( '0' .. '7' ) ( '0' .. '7' ) | '\\\\' ( '0' .. '7' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start OCTAL_ESCAPE
 *
 * Looks to match the characters the constitute the token OCTAL_ESCAPE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mOCTAL_ESCAPE(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    {
        //  IQL.g:581:5: ( '\\\\' ( '0' .. '3' ) ( '0' .. '7' ) ( '0' .. '7' ) | '\\\\' ( '0' .. '7' ) ( '0' .. '7' ) | '\\\\' ( '0' .. '7' ) )
        
        ANTLR3_UINT32 alt5;

        alt5=3;

        switch ( LA(1) ) 
        {
        case '\\':
        	{
        		switch ( LA(2) ) 
        		{
        		case '0':
        		case '1':
        		case '2':
        		case '3':
        			{
        				switch ( LA(3) ) 
        				{
        				case '0':
        				case '1':
        				case '2':
        				case '3':
        				case '4':
        				case '5':
        				case '6':
        				case '7':
        					{
        						switch ( LA(4) ) 
        						{
        						case '0':
        						case '1':
        						case '2':
        						case '3':
        						case '4':
        						case '5':
        						case '6':
        						case '7':
        							{
        								alt5=1;
        							}
        						    break;

        						default:
        						    alt5=2;}

        					}
        				    break;

        				default:
        				    alt5=3;}

        			}
        		    break;
        		case '4':
        		case '5':
        		case '6':
        		case '7':
        			{
        				switch ( LA(3) ) 
        				{
        				case '0':
        				case '1':
        				case '2':
        				case '3':
        				case '4':
        				case '5':
        				case '6':
        				case '7':
        					{
        						alt5=2;
        					}
        				    break;

        				default:
        				    alt5=3;}

        			}
        		    break;

        		default:
        		    CONSTRUCTEX();
        		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        		    EXCEPTION->message      = (void *)"";
        		    EXCEPTION->decisionNum  = 5;
        		    EXCEPTION->state        = 1;


        		    goto ruleOCTAL_ESCAPEEx;
        		}

        	}
            break;

        default:
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            EXCEPTION->message      = (void *)"";
            EXCEPTION->decisionNum  = 5;
            EXCEPTION->state        = 0;


            goto ruleOCTAL_ESCAPEEx;
        }

        switch (alt5) 
        {
    	case 1:
    	    // IQL.g:581:9: '\\\\' ( '0' .. '3' ) ( '0' .. '7' ) ( '0' .. '7' )
    	    {
    	        MATCHC('\\'); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleOCTAL_ESCAPEEx;
    	        }

    	        // IQL.g:581:14: ( '0' .. '3' )
    	        // IQL.g:581:15: '0' .. '3'
    	        {
    	            MATCHRANGE('0', '3'); 
    	            if  (HASEXCEPTION())
    	            {
    	                goto ruleOCTAL_ESCAPEEx;
    	            }


    	        }

    	        // IQL.g:581:25: ( '0' .. '7' )
    	        // IQL.g:581:26: '0' .. '7'
    	        {
    	            MATCHRANGE('0', '7'); 
    	            if  (HASEXCEPTION())
    	            {
    	                goto ruleOCTAL_ESCAPEEx;
    	            }


    	        }

    	        // IQL.g:581:36: ( '0' .. '7' )
    	        // IQL.g:581:37: '0' .. '7'
    	        {
    	            MATCHRANGE('0', '7'); 
    	            if  (HASEXCEPTION())
    	            {
    	                goto ruleOCTAL_ESCAPEEx;
    	            }


    	        }


    	    }
    	    break;
    	case 2:
    	    // IQL.g:582:9: '\\\\' ( '0' .. '7' ) ( '0' .. '7' )
    	    {
    	        MATCHC('\\'); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleOCTAL_ESCAPEEx;
    	        }

    	        // IQL.g:582:14: ( '0' .. '7' )
    	        // IQL.g:582:15: '0' .. '7'
    	        {
    	            MATCHRANGE('0', '7'); 
    	            if  (HASEXCEPTION())
    	            {
    	                goto ruleOCTAL_ESCAPEEx;
    	            }


    	        }

    	        // IQL.g:582:25: ( '0' .. '7' )
    	        // IQL.g:582:26: '0' .. '7'
    	        {
    	            MATCHRANGE('0', '7'); 
    	            if  (HASEXCEPTION())
    	            {
    	                goto ruleOCTAL_ESCAPEEx;
    	            }


    	        }


    	    }
    	    break;
    	case 3:
    	    // IQL.g:583:9: '\\\\' ( '0' .. '7' )
    	    {
    	        MATCHC('\\'); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleOCTAL_ESCAPEEx;
    	        }

    	        // IQL.g:583:14: ( '0' .. '7' )
    	        // IQL.g:583:15: '0' .. '7'
    	        {
    	            MATCHRANGE('0', '7'); 
    	            if  (HASEXCEPTION())
    	            {
    	                goto ruleOCTAL_ESCAPEEx;
    	            }


    	        }


    	    }
    	    break;

        }
    }


    // This is where rules clean up and exit
    //
    goto ruleOCTAL_ESCAPEEx; /* Prevent compiler warnings */
    ruleOCTAL_ESCAPEEx: ;

}
// $ANTLR end OCTAL_ESCAPE

//   Comes from: 588:2: ( ( '0' .. '9' | 'A' .. 'F' | 'a' .. 'f' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start HEX_DIGIT
 *
 * Looks to match the characters the constitute the token HEX_DIGIT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mHEX_DIGIT(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // IQL.g:588:2: ( ( '0' .. '9' | 'A' .. 'F' | 'a' .. 'f' ) )
    // IQL.g:588:4: ( '0' .. '9' | 'A' .. 'F' | 'a' .. 'f' )
    {
        if ( ((LA(1) >= '0') && (LA(1) <= '9')) || ((LA(1) >= 'A') && (LA(1) <= 'F')) || ((LA(1) >= 'a') && (LA(1) <= 'f')) )
        {
            CONSUME();

        }
        else 
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleHEX_DIGITEx;
        }


    }



    // This is where rules clean up and exit
    //
    goto ruleHEX_DIGITEx; /* Prevent compiler warnings */
    ruleHEX_DIGITEx: ;

}
// $ANTLR end HEX_DIGIT

//   Comes from: 592:5: ( '\\\\' 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start UNICODE_ESCAPE
 *
 * Looks to match the characters the constitute the token UNICODE_ESCAPE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mUNICODE_ESCAPE(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // IQL.g:592:5: ( '\\\\' 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT )
    // IQL.g:592:9: '\\\\' 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT
    {
        MATCHC('\\'); 
        if  (HASEXCEPTION())
        {
            goto ruleUNICODE_ESCAPEEx;
        }

        MATCHC('u'); 
        if  (HASEXCEPTION())
        {
            goto ruleUNICODE_ESCAPEEx;
        }

        /* 592:9: '\\\\' 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT */
        mHEX_DIGIT(ctx ); 
        if  (HASEXCEPTION())
        {
            goto ruleUNICODE_ESCAPEEx;
        }

        /* 592:9: '\\\\' 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT */
        mHEX_DIGIT(ctx ); 
        if  (HASEXCEPTION())
        {
            goto ruleUNICODE_ESCAPEEx;
        }

        /* 592:9: '\\\\' 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT */
        mHEX_DIGIT(ctx ); 
        if  (HASEXCEPTION())
        {
            goto ruleUNICODE_ESCAPEEx;
        }

        /* 592:9: '\\\\' 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT */
        mHEX_DIGIT(ctx ); 
        if  (HASEXCEPTION())
        {
            goto ruleUNICODE_ESCAPEEx;
        }


    }



    // This is where rules clean up and exit
    //
    goto ruleUNICODE_ESCAPEEx; /* Prevent compiler warnings */
    ruleUNICODE_ESCAPEEx: ;

}
// $ANTLR end UNICODE_ESCAPE

//   Comes from: 595:5: ( ( ' ' | '\\r' | '\\t' | '\\u000C' | '\\n' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start WS
 *
 * Looks to match the characters the constitute the token WS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mWS(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = WS;
       
    
    // IQL.g:595:5: ( ( ' ' | '\\r' | '\\t' | '\\u000C' | '\\n' ) )
    // IQL.g:595:8: ( ' ' | '\\r' | '\\t' | '\\u000C' | '\\n' )
    {
        if ( ((LA(1) >= '\t') && (LA(1) <= '\n')) || ((LA(1) >= '\f') && (LA(1) <= '\r')) || LA(1) == ' ' )
        {
            CONSUME();

        }
        else 
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleWSEx;
        }

        {
            LEXSTATE->channel=HIDDEN;
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleWSEx; /* Prevent compiler warnings */
    ruleWSEx: ;

}
// $ANTLR end WS

//   Comes from: 599:5: ( '/*' ( options {greedy=false; } : . )* '*/' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ML_COMMENT
 *
 * Looks to match the characters the constitute the token ML_COMMENT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mML_COMMENT(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = ML_COMMENT;
       
    
    // IQL.g:599:5: ( '/*' ( options {greedy=false; } : . )* '*/' )
    // IQL.g:599:9: '/*' ( options {greedy=false; } : . )* '*/'
    {
        MATCHS(lit_86); 
        if  (HASEXCEPTION())
        {
            goto ruleML_COMMENTEx;
        }



        // IQL.g:599:14: ( options {greedy=false; } : . )*

        for (;;)
        {
            int alt6=2;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA6_0 = LA(1);
                if ( (LA6_0 == '*') ) 
                {
                    {
                       /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                        */
                        int LA6_1 = LA(2);
                        if ( (LA6_1 == '/') ) 
                        {
                            alt6=2;
                        }
                        else if ( (((LA6_1 >= 0x0000) && (LA6_1 <= '.')) || ((LA6_1 >= '0') && (LA6_1 <= 0xFFFF))) ) 
                        {
                            alt6=1;
                        }

                    }
                }
                else if ( (((LA6_0 >= 0x0000) && (LA6_0 <= ')')) || ((LA6_0 >= '+') && (LA6_0 <= 0xFFFF))) ) 
                {
                    alt6=1;
                }

            }
            switch (alt6) 
            {
        	case 1:
        	    // IQL.g:599:42: .
        	    {
        	        MATCHANY(); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleML_COMMENTEx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop6;	/* break out of the loop */
        	    break;
            }
        }
        loop6: ; /* Jump out to here if this rule does not match */

        MATCHS(lit_87); 
        if  (HASEXCEPTION())
        {
            goto ruleML_COMMENTEx;
        }


        {
            LEXSTATE->channel=HIDDEN;
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleML_COMMENTEx; /* Prevent compiler warnings */
    ruleML_COMMENTEx: ;

}
// $ANTLR end ML_COMMENT

//   Comes from: 603:5: ( '//' (~ ( '\\n' | '\\r' ) )* ( '\\r' )? '\\n' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SL_COMMENT
 *
 * Looks to match the characters the constitute the token SL_COMMENT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSL_COMMENT(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = SL_COMMENT;
       
    
    // IQL.g:603:5: ( '//' (~ ( '\\n' | '\\r' ) )* ( '\\r' )? '\\n' )
    // IQL.g:603:7: '//' (~ ( '\\n' | '\\r' ) )* ( '\\r' )? '\\n'
    {
        MATCHS(lit_88); 
        if  (HASEXCEPTION())
        {
            goto ruleSL_COMMENTEx;
        }



        // IQL.g:603:12: (~ ( '\\n' | '\\r' ) )*

        for (;;)
        {
            int alt7=2;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA7_0 = LA(1);
                if ( (((LA7_0 >= 0x0000) && (LA7_0 <= '\t')) || ((LA7_0 >= 0x000B) && (LA7_0 <= '\f')) || ((LA7_0 >= 0x000E) && (LA7_0 <= 0xFFFF))) ) 
                {
                    alt7=1;
                }

            }
            switch (alt7) 
            {
        	case 1:
        	    // IQL.g:603:12: ~ ( '\\n' | '\\r' )
        	    {
        	        if ( ((LA(1) >= 0x0000) && (LA(1) <= '\t')) || ((LA(1) >= 0x000B) && (LA(1) <= '\f')) || ((LA(1) >= 0x000E) && (LA(1) <= 0xFFFF)) )
        	        {
        	            CONSUME();

        	        }
        	        else 
        	        {
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	            LRECOVER();    goto ruleSL_COMMENTEx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop7;	/* break out of the loop */
        	    break;
            }
        }
        loop7: ; /* Jump out to here if this rule does not match */


        // IQL.g:603:26: ( '\\r' )?
        {
            int alt8=2;
            switch ( LA(1) ) 
            {
                case '\r':
                	{
                		alt8=1;
                	}
                    break;
            }

            switch (alt8) 
            {
        	case 1:
        	    // IQL.g:603:26: '\\r'
        	    {
        	        MATCHC('\r'); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleSL_COMMENTEx;
        	        }


        	    }
        	    break;

            }
        }
        MATCHC('\n'); 
        if  (HASEXCEPTION())
        {
            goto ruleSL_COMMENTEx;
        }

        {
            LEXSTATE->channel=HIDDEN;
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleSL_COMMENTEx; /* Prevent compiler warnings */
    ruleSL_COMMENTEx: ;

}
// $ANTLR end SL_COMMENT

//   Comes from: 607:2: ( ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )* )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ID
 *
 * Looks to match the characters the constitute the token ID
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mID(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = ID;
       
    
    // IQL.g:607:2: ( ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )* )
    // IQL.g:607:4: ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )*
    {
        if ( ((LA(1) >= 'A') && (LA(1) <= 'Z')) || LA(1) == '_' || ((LA(1) >= 'a') && (LA(1) <= 'z')) )
        {
            CONSUME();

        }
        else 
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleIDEx;
        }


        // IQL.g:607:28: ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )*

        for (;;)
        {
            int alt9=2;
            switch ( LA(1) ) 
            {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            case 'A':
            case 'B':
            case 'C':
            case 'D':
            case 'E':
            case 'F':
            case 'G':
            case 'H':
            case 'I':
            case 'J':
            case 'K':
            case 'L':
            case 'M':
            case 'N':
            case 'O':
            case 'P':
            case 'Q':
            case 'R':
            case 'S':
            case 'T':
            case 'U':
            case 'V':
            case 'W':
            case 'X':
            case 'Y':
            case 'Z':
            case '_':
            case 'a':
            case 'b':
            case 'c':
            case 'd':
            case 'e':
            case 'f':
            case 'g':
            case 'h':
            case 'i':
            case 'j':
            case 'k':
            case 'l':
            case 'm':
            case 'n':
            case 'o':
            case 'p':
            case 'q':
            case 'r':
            case 's':
            case 't':
            case 'u':
            case 'v':
            case 'w':
            case 'x':
            case 'y':
            case 'z':
            	{
            		alt9=1;
            	}
                break;

            }

            switch (alt9) 
            {
        	case 1:
        	    // IQL.g:
        	    {
        	        if ( ((LA(1) >= '0') && (LA(1) <= '9')) || ((LA(1) >= 'A') && (LA(1) <= 'Z')) || LA(1) == '_' || ((LA(1) >= 'a') && (LA(1) <= 'z')) )
        	        {
        	            CONSUME();

        	        }
        	        else 
        	        {
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	            LRECOVER();    goto ruleIDEx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop9;	/* break out of the loop */
        	    break;
            }
        }
        loop9: ; /* Jump out to here if this rule does not match */


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleIDEx; /* Prevent compiler warnings */
    ruleIDEx: ;

}
// $ANTLR end ID

//   Comes from: 611:2: ( '`' (~ ( '`' ) )* '`' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start QUOTED_ID
 *
 * Looks to match the characters the constitute the token QUOTED_ID
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mQUOTED_ID(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = QUOTED_ID;
       
    
    // IQL.g:611:2: ( '`' (~ ( '`' ) )* '`' )
    // IQL.g:611:4: '`' (~ ( '`' ) )* '`'
    {
        MATCHC('`'); 
        if  (HASEXCEPTION())
        {
            goto ruleQUOTED_IDEx;
        }


        // IQL.g:611:8: (~ ( '`' ) )*

        for (;;)
        {
            int alt10=2;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA10_0 = LA(1);
                if ( (((LA10_0 >= 0x0000) && (LA10_0 <= '_')) || ((LA10_0 >= 'a') && (LA10_0 <= 0xFFFF))) ) 
                {
                    alt10=1;
                }

            }
            switch (alt10) 
            {
        	case 1:
        	    // IQL.g:611:8: ~ ( '`' )
        	    {
        	        if ( ((LA(1) >= 0x0000) && (LA(1) <= '_')) || ((LA(1) >= 'a') && (LA(1) <= 0xFFFF)) )
        	        {
        	            CONSUME();

        	        }
        	        else 
        	        {
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	            LRECOVER();    goto ruleQUOTED_IDEx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop10;	/* break out of the loop */
        	    break;
            }
        }
        loop10: ; /* Jump out to here if this rule does not match */

        MATCHC('`'); 
        if  (HASEXCEPTION())
        {
            goto ruleQUOTED_IDEx;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleQUOTED_IDEx; /* Prevent compiler warnings */
    ruleQUOTED_IDEx: ;

}
// $ANTLR end QUOTED_ID

//   Comes from: 617:2: ( 'L' 'L' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BIGINT_SUFFIX
 *
 * Looks to match the characters the constitute the token BIGINT_SUFFIX
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mBIGINT_SUFFIX(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // IQL.g:617:2: ( 'L' 'L' )
    // IQL.g:617:4: 'L' 'L'
    {
        MATCHC('L'); 
        if  (HASEXCEPTION())
        {
            goto ruleBIGINT_SUFFIXEx;
        }

        MATCHC('L'); 
        if  (HASEXCEPTION())
        {
            goto ruleBIGINT_SUFFIXEx;
        }


    }



    // This is where rules clean up and exit
    //
    goto ruleBIGINT_SUFFIXEx; /* Prevent compiler warnings */
    ruleBIGINT_SUFFIXEx: ;

}
// $ANTLR end BIGINT_SUFFIX

//   Comes from: 621:5: ( '0' ( 'x' | 'X' ) ( HEX_DIGIT )+ ( BIGINT_SUFFIX )? )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start HEX_INTEGER_LITERAL
 *
 * Looks to match the characters the constitute the token HEX_INTEGER_LITERAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mHEX_INTEGER_LITERAL(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = HEX_INTEGER_LITERAL;
       
    
    // IQL.g:621:5: ( '0' ( 'x' | 'X' ) ( HEX_DIGIT )+ ( BIGINT_SUFFIX )? )
    // IQL.g:622:5: '0' ( 'x' | 'X' ) ( HEX_DIGIT )+ ( BIGINT_SUFFIX )?
    {
        MATCHC('0'); 
        if  (HASEXCEPTION())
        {
            goto ruleHEX_INTEGER_LITERALEx;
        }

        if ( LA(1) == 'X' || LA(1) == 'x' )
        {
            CONSUME();

        }
        else 
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleHEX_INTEGER_LITERALEx;
        }

        // IQL.g:622:19: ( HEX_DIGIT )+
        {
            int cnt11=0;

            for (;;)
            {
                int alt11=2;
        	switch ( LA(1) ) 
        	{
        	case '0':
        	case '1':
        	case '2':
        	case '3':
        	case '4':
        	case '5':
        	case '6':
        	case '7':
        	case '8':
        	case '9':
        	case 'A':
        	case 'B':
        	case 'C':
        	case 'D':
        	case 'E':
        	case 'F':
        	case 'a':
        	case 'b':
        	case 'c':
        	case 'd':
        	case 'e':
        	case 'f':
        		{
        			alt11=1;
        		}
        	    break;

        	}

        	switch (alt11) 
        	{
        	    case 1:
        	        // IQL.g:622:19: HEX_DIGIT
        	        {
        	            /* 622:19: HEX_DIGIT */
        	            mHEX_DIGIT(ctx ); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleHEX_INTEGER_LITERALEx;
        	            }


        	        }
        	        break;

        	    default:
        	    
        		if ( cnt11 >= 1 )
        		{
        		    goto loop11;
        		}
        		/* mismatchedSetEx()
        		 */
        		CONSTRUCTEX();
        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        		goto ruleHEX_INTEGER_LITERALEx;
        	}
        	cnt11++;
            }
            loop11: ;	/* Jump to here if this rule does not match */
        }

        // IQL.g:622:30: ( BIGINT_SUFFIX )?
        {
            int alt12=2;
            switch ( LA(1) ) 
            {
                case 'L':
                	{
                		alt12=1;
                	}
                    break;
            }

            switch (alt12) 
            {
        	case 1:
        	    // IQL.g:622:30: BIGINT_SUFFIX
        	    {
        	        /* 622:30: BIGINT_SUFFIX */
        	        mBIGINT_SUFFIX(ctx ); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleHEX_INTEGER_LITERALEx;
        	        }


        	    }
        	    break;

            }
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleHEX_INTEGER_LITERALEx; /* Prevent compiler warnings */
    ruleHEX_INTEGER_LITERALEx: ;

}
// $ANTLR end HEX_INTEGER_LITERAL

//   Comes from: 626:5: ( ( '0' | '1' .. '9' ( '0' .. '9' )* ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DECIMAL_INTEGER_LITERAL
 *
 * Looks to match the characters the constitute the token DECIMAL_INTEGER_LITERAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mDECIMAL_INTEGER_LITERAL(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = DECIMAL_INTEGER_LITERAL;
       
    
    // IQL.g:626:5: ( ( '0' | '1' .. '9' ( '0' .. '9' )* ) )
    // IQL.g:627:5: ( '0' | '1' .. '9' ( '0' .. '9' )* )
    {

        // IQL.g:627:5: ( '0' | '1' .. '9' ( '0' .. '9' )* )
        {
            int alt14=2;
            switch ( LA(1) ) 
            {
            case '0':
            	{
            		alt14=1;
            	}
                break;
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            	{
            		alt14=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 14;
                EXCEPTION->state        = 0;


                goto ruleDECIMAL_INTEGER_LITERALEx;
            }

            switch (alt14) 
            {
        	case 1:
        	    // IQL.g:627:6: '0'
        	    {
        	        MATCHC('0'); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleDECIMAL_INTEGER_LITERALEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // IQL.g:627:12: '1' .. '9' ( '0' .. '9' )*
        	    {
        	        MATCHRANGE('1', '9'); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleDECIMAL_INTEGER_LITERALEx;
        	        }


        	        // IQL.g:627:21: ( '0' .. '9' )*

        	        for (;;)
        	        {
        	            int alt13=2;
        	            switch ( LA(1) ) 
        	            {
        	            case '0':
        	            case '1':
        	            case '2':
        	            case '3':
        	            case '4':
        	            case '5':
        	            case '6':
        	            case '7':
        	            case '8':
        	            case '9':
        	            	{
        	            		alt13=1;
        	            	}
        	                break;

        	            }

        	            switch (alt13) 
        	            {
        	        	case 1:
        	        	    // IQL.g:627:21: '0' .. '9'
        	        	    {
        	        	        MATCHRANGE('0', '9'); 
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleDECIMAL_INTEGER_LITERALEx;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop13;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop13: ; /* Jump out to here if this rule does not match */


        	    }
        	    break;

            }
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleDECIMAL_INTEGER_LITERALEx; /* Prevent compiler warnings */
    ruleDECIMAL_INTEGER_LITERALEx: ;

}
// $ANTLR end DECIMAL_INTEGER_LITERAL

//   Comes from: 631:5: ( ( '0' | '1' .. '9' ( '0' .. '9' )* ) BIGINT_SUFFIX )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DECIMAL_BIGINT_LITERAL
 *
 * Looks to match the characters the constitute the token DECIMAL_BIGINT_LITERAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mDECIMAL_BIGINT_LITERAL(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = DECIMAL_BIGINT_LITERAL;
       
    
    // IQL.g:631:5: ( ( '0' | '1' .. '9' ( '0' .. '9' )* ) BIGINT_SUFFIX )
    // IQL.g:632:5: ( '0' | '1' .. '9' ( '0' .. '9' )* ) BIGINT_SUFFIX
    {

        // IQL.g:632:5: ( '0' | '1' .. '9' ( '0' .. '9' )* )
        {
            int alt16=2;
            switch ( LA(1) ) 
            {
            case '0':
            	{
            		alt16=1;
            	}
                break;
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            	{
            		alt16=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 16;
                EXCEPTION->state        = 0;


                goto ruleDECIMAL_BIGINT_LITERALEx;
            }

            switch (alt16) 
            {
        	case 1:
        	    // IQL.g:632:6: '0'
        	    {
        	        MATCHC('0'); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleDECIMAL_BIGINT_LITERALEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // IQL.g:632:12: '1' .. '9' ( '0' .. '9' )*
        	    {
        	        MATCHRANGE('1', '9'); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleDECIMAL_BIGINT_LITERALEx;
        	        }


        	        // IQL.g:632:21: ( '0' .. '9' )*

        	        for (;;)
        	        {
        	            int alt15=2;
        	            switch ( LA(1) ) 
        	            {
        	            case '0':
        	            case '1':
        	            case '2':
        	            case '3':
        	            case '4':
        	            case '5':
        	            case '6':
        	            case '7':
        	            case '8':
        	            case '9':
        	            	{
        	            		alt15=1;
        	            	}
        	                break;

        	            }

        	            switch (alt15) 
        	            {
        	        	case 1:
        	        	    // IQL.g:632:21: '0' .. '9'
        	        	    {
        	        	        MATCHRANGE('0', '9'); 
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleDECIMAL_BIGINT_LITERALEx;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop15;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop15: ; /* Jump out to here if this rule does not match */


        	    }
        	    break;

            }
        }
        /* 632:5: ( '0' | '1' .. '9' ( '0' .. '9' )* ) BIGINT_SUFFIX */
        mBIGINT_SUFFIX(ctx ); 
        if  (HASEXCEPTION())
        {
            goto ruleDECIMAL_BIGINT_LITERALEx;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleDECIMAL_BIGINT_LITERALEx; /* Prevent compiler warnings */
    ruleDECIMAL_BIGINT_LITERALEx: ;

}
// $ANTLR end DECIMAL_BIGINT_LITERAL

//   Comes from: 636:5: ( ( '0' .. '9' )+ '.' ( '0' .. '9' )* EXPONENT ( FLOAT_SUFFIX )? | '.' ( '0' .. '9' )+ EXPONENT ( FLOAT_SUFFIX )? | ( '0' .. '9' )+ ( EXPONENT ( FLOAT_SUFFIX )? | FLOAT_SUFFIX ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start FLOATING_POINT_LITERAL
 *
 * Looks to match the characters the constitute the token FLOATING_POINT_LITERAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mFLOATING_POINT_LITERAL(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = FLOATING_POINT_LITERAL;
       
    
    {
        //  IQL.g:636:5: ( ( '0' .. '9' )+ '.' ( '0' .. '9' )* EXPONENT ( FLOAT_SUFFIX )? | '.' ( '0' .. '9' )+ EXPONENT ( FLOAT_SUFFIX )? | ( '0' .. '9' )+ ( EXPONENT ( FLOAT_SUFFIX )? | FLOAT_SUFFIX ) )
        
        ANTLR3_UINT32 alt25;

        alt25=3;

        alt25 = cdfa25.predict(ctx, RECOGNIZER, ISTREAM, &cdfa25);
        if  (HASEXCEPTION())
        {
            goto ruleFLOATING_POINT_LITERALEx;
        }

        switch (alt25) 
        {
    	case 1:
    	    // IQL.g:636:9: ( '0' .. '9' )+ '.' ( '0' .. '9' )* EXPONENT ( FLOAT_SUFFIX )?
    	    {
    	        // IQL.g:636:9: ( '0' .. '9' )+
    	        {
    	            int cnt17=0;

    	            for (;;)
    	            {
    	                int alt17=2;
    	        	switch ( LA(1) ) 
    	        	{
    	        	case '0':
    	        	case '1':
    	        	case '2':
    	        	case '3':
    	        	case '4':
    	        	case '5':
    	        	case '6':
    	        	case '7':
    	        	case '8':
    	        	case '9':
    	        		{
    	        			alt17=1;
    	        		}
    	        	    break;

    	        	}

    	        	switch (alt17) 
    	        	{
    	        	    case 1:
    	        	        // IQL.g:636:10: '0' .. '9'
    	        	        {
    	        	            MATCHRANGE('0', '9'); 
    	        	            if  (HASEXCEPTION())
    	        	            {
    	        	                goto ruleFLOATING_POINT_LITERALEx;
    	        	            }


    	        	        }
    	        	        break;

    	        	    default:
    	        	    
    	        		if ( cnt17 >= 1 )
    	        		{
    	        		    goto loop17;
    	        		}
    	        		/* mismatchedSetEx()
    	        		 */
    	        		CONSTRUCTEX();
    	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
    	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


    	        		goto ruleFLOATING_POINT_LITERALEx;
    	        	}
    	        	cnt17++;
    	            }
    	            loop17: ;	/* Jump to here if this rule does not match */
    	        }
    	        MATCHC('.'); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleFLOATING_POINT_LITERALEx;
    	        }


    	        // IQL.g:636:25: ( '0' .. '9' )*

    	        for (;;)
    	        {
    	            int alt18=2;
    	            switch ( LA(1) ) 
    	            {
    	            case '0':
    	            case '1':
    	            case '2':
    	            case '3':
    	            case '4':
    	            case '5':
    	            case '6':
    	            case '7':
    	            case '8':
    	            case '9':
    	            	{
    	            		alt18=1;
    	            	}
    	                break;

    	            }

    	            switch (alt18) 
    	            {
    	        	case 1:
    	        	    // IQL.g:636:26: '0' .. '9'
    	        	    {
    	        	        MATCHRANGE('0', '9'); 
    	        	        if  (HASEXCEPTION())
    	        	        {
    	        	            goto ruleFLOATING_POINT_LITERALEx;
    	        	        }


    	        	    }
    	        	    break;

    	        	default:
    	        	    goto loop18;	/* break out of the loop */
    	        	    break;
    	            }
    	        }
    	        loop18: ; /* Jump out to here if this rule does not match */

    	        /* 636:9: ( '0' .. '9' )+ '.' ( '0' .. '9' )* EXPONENT ( FLOAT_SUFFIX )? */
    	        mEXPONENT(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleFLOATING_POINT_LITERALEx;
    	        }


    	        // IQL.g:636:46: ( FLOAT_SUFFIX )?
    	        {
    	            int alt19=2;
    	            switch ( LA(1) ) 
    	            {
    	                case 'D':
    	                case 'F':
    	                case 'd':
    	                case 'f':
    	                	{
    	                		alt19=1;
    	                	}
    	                    break;
    	            }

    	            switch (alt19) 
    	            {
    	        	case 1:
    	        	    // IQL.g:636:46: FLOAT_SUFFIX
    	        	    {
    	        	        /* 636:46: FLOAT_SUFFIX */
    	        	        mFLOAT_SUFFIX(ctx ); 
    	        	        if  (HASEXCEPTION())
    	        	        {
    	        	            goto ruleFLOATING_POINT_LITERALEx;
    	        	        }


    	        	    }
    	        	    break;

    	            }
    	        }

    	    }
    	    break;
    	case 2:
    	    // IQL.g:637:9: '.' ( '0' .. '9' )+ EXPONENT ( FLOAT_SUFFIX )?
    	    {
    	        MATCHC('.'); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleFLOATING_POINT_LITERALEx;
    	        }

    	        // IQL.g:637:13: ( '0' .. '9' )+
    	        {
    	            int cnt20=0;

    	            for (;;)
    	            {
    	                int alt20=2;
    	        	switch ( LA(1) ) 
    	        	{
    	        	case '0':
    	        	case '1':
    	        	case '2':
    	        	case '3':
    	        	case '4':
    	        	case '5':
    	        	case '6':
    	        	case '7':
    	        	case '8':
    	        	case '9':
    	        		{
    	        			alt20=1;
    	        		}
    	        	    break;

    	        	}

    	        	switch (alt20) 
    	        	{
    	        	    case 1:
    	        	        // IQL.g:637:14: '0' .. '9'
    	        	        {
    	        	            MATCHRANGE('0', '9'); 
    	        	            if  (HASEXCEPTION())
    	        	            {
    	        	                goto ruleFLOATING_POINT_LITERALEx;
    	        	            }


    	        	        }
    	        	        break;

    	        	    default:
    	        	    
    	        		if ( cnt20 >= 1 )
    	        		{
    	        		    goto loop20;
    	        		}
    	        		/* mismatchedSetEx()
    	        		 */
    	        		CONSTRUCTEX();
    	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
    	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


    	        		goto ruleFLOATING_POINT_LITERALEx;
    	        	}
    	        	cnt20++;
    	            }
    	            loop20: ;	/* Jump to here if this rule does not match */
    	        }
    	        /* 637:9: '.' ( '0' .. '9' )+ EXPONENT ( FLOAT_SUFFIX )? */
    	        mEXPONENT(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleFLOATING_POINT_LITERALEx;
    	        }


    	        // IQL.g:637:34: ( FLOAT_SUFFIX )?
    	        {
    	            int alt21=2;
    	            switch ( LA(1) ) 
    	            {
    	                case 'D':
    	                case 'F':
    	                case 'd':
    	                case 'f':
    	                	{
    	                		alt21=1;
    	                	}
    	                    break;
    	            }

    	            switch (alt21) 
    	            {
    	        	case 1:
    	        	    // IQL.g:637:34: FLOAT_SUFFIX
    	        	    {
    	        	        /* 637:34: FLOAT_SUFFIX */
    	        	        mFLOAT_SUFFIX(ctx ); 
    	        	        if  (HASEXCEPTION())
    	        	        {
    	        	            goto ruleFLOATING_POINT_LITERALEx;
    	        	        }


    	        	    }
    	        	    break;

    	            }
    	        }

    	    }
    	    break;
    	case 3:
    	    // IQL.g:638:9: ( '0' .. '9' )+ ( EXPONENT ( FLOAT_SUFFIX )? | FLOAT_SUFFIX )
    	    {
    	        // IQL.g:638:9: ( '0' .. '9' )+
    	        {
    	            int cnt22=0;

    	            for (;;)
    	            {
    	                int alt22=2;
    	        	switch ( LA(1) ) 
    	        	{
    	        	case '0':
    	        	case '1':
    	        	case '2':
    	        	case '3':
    	        	case '4':
    	        	case '5':
    	        	case '6':
    	        	case '7':
    	        	case '8':
    	        	case '9':
    	        		{
    	        			alt22=1;
    	        		}
    	        	    break;

    	        	}

    	        	switch (alt22) 
    	        	{
    	        	    case 1:
    	        	        // IQL.g:638:10: '0' .. '9'
    	        	        {
    	        	            MATCHRANGE('0', '9'); 
    	        	            if  (HASEXCEPTION())
    	        	            {
    	        	                goto ruleFLOATING_POINT_LITERALEx;
    	        	            }


    	        	        }
    	        	        break;

    	        	    default:
    	        	    
    	        		if ( cnt22 >= 1 )
    	        		{
    	        		    goto loop22;
    	        		}
    	        		/* mismatchedSetEx()
    	        		 */
    	        		CONSTRUCTEX();
    	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
    	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


    	        		goto ruleFLOATING_POINT_LITERALEx;
    	        	}
    	        	cnt22++;
    	            }
    	            loop22: ;	/* Jump to here if this rule does not match */
    	        }

    	        // IQL.g:638:21: ( EXPONENT ( FLOAT_SUFFIX )? | FLOAT_SUFFIX )
    	        {
    	            int alt24=2;
    	            switch ( LA(1) ) 
    	            {
    	            case 'E':
    	            case 'e':
    	            	{
    	            		alt24=1;
    	            	}
    	                break;
    	            case 'D':
    	            case 'F':
    	            case 'd':
    	            case 'f':
    	            	{
    	            		alt24=2;
    	            	}
    	                break;

    	            default:
    	                CONSTRUCTEX();
    	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
    	                EXCEPTION->message      = (void *)"";
    	                EXCEPTION->decisionNum  = 24;
    	                EXCEPTION->state        = 0;


    	                goto ruleFLOATING_POINT_LITERALEx;
    	            }

    	            switch (alt24) 
    	            {
    	        	case 1:
    	        	    // IQL.g:638:25: EXPONENT ( FLOAT_SUFFIX )?
    	        	    {
    	        	        /* 638:25: EXPONENT ( FLOAT_SUFFIX )? */
    	        	        mEXPONENT(ctx ); 
    	        	        if  (HASEXCEPTION())
    	        	        {
    	        	            goto ruleFLOATING_POINT_LITERALEx;
    	        	        }


    	        	        // IQL.g:638:34: ( FLOAT_SUFFIX )?
    	        	        {
    	        	            int alt23=2;
    	        	            switch ( LA(1) ) 
    	        	            {
    	        	                case 'D':
    	        	                case 'F':
    	        	                case 'd':
    	        	                case 'f':
    	        	                	{
    	        	                		alt23=1;
    	        	                	}
    	        	                    break;
    	        	            }

    	        	            switch (alt23) 
    	        	            {
    	        	        	case 1:
    	        	        	    // IQL.g:638:34: FLOAT_SUFFIX
    	        	        	    {
    	        	        	        /* 638:34: FLOAT_SUFFIX */
    	        	        	        mFLOAT_SUFFIX(ctx ); 
    	        	        	        if  (HASEXCEPTION())
    	        	        	        {
    	        	        	            goto ruleFLOATING_POINT_LITERALEx;
    	        	        	        }


    	        	        	    }
    	        	        	    break;

    	        	            }
    	        	        }

    	        	    }
    	        	    break;
    	        	case 2:
    	        	    // IQL.g:639:9: FLOAT_SUFFIX
    	        	    {
    	        	        /* 639:9: FLOAT_SUFFIX */
    	        	        mFLOAT_SUFFIX(ctx ); 
    	        	        if  (HASEXCEPTION())
    	        	        {
    	        	            goto ruleFLOATING_POINT_LITERALEx;
    	        	        }


    	        	    }
    	        	    break;

    	            }
    	        }

    	    }
    	    break;

        }
    }
	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleFLOATING_POINT_LITERALEx; /* Prevent compiler warnings */
    ruleFLOATING_POINT_LITERALEx: ;

}
// $ANTLR end FLOATING_POINT_LITERAL

//   Comes from: 645:2: ( ( 'e' | 'E' ) ( '+' | '-' )? ( '0' .. '9' )+ )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start EXPONENT
 *
 * Looks to match the characters the constitute the token EXPONENT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mEXPONENT(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // IQL.g:645:2: ( ( 'e' | 'E' ) ( '+' | '-' )? ( '0' .. '9' )+ )
    // IQL.g:645:4: ( 'e' | 'E' ) ( '+' | '-' )? ( '0' .. '9' )+
    {
        if ( LA(1) == 'E' || LA(1) == 'e' )
        {
            CONSUME();

        }
        else 
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleEXPONENTEx;
        }


        // IQL.g:645:14: ( '+' | '-' )?
        {
            int alt26=2;
            switch ( LA(1) ) 
            {
                case '+':
                case '-':
                	{
                		alt26=1;
                	}
                    break;
            }

            switch (alt26) 
            {
        	case 1:
        	    // IQL.g:
        	    {
        	        if ( LA(1) == '+' || LA(1) == '-' )
        	        {
        	            CONSUME();

        	        }
        	        else 
        	        {
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	            LRECOVER();    goto ruleEXPONENTEx;
        	        }


        	    }
        	    break;

            }
        }
        // IQL.g:645:25: ( '0' .. '9' )+
        {
            int cnt27=0;

            for (;;)
            {
                int alt27=2;
        	switch ( LA(1) ) 
        	{
        	case '0':
        	case '1':
        	case '2':
        	case '3':
        	case '4':
        	case '5':
        	case '6':
        	case '7':
        	case '8':
        	case '9':
        		{
        			alt27=1;
        		}
        	    break;

        	}

        	switch (alt27) 
        	{
        	    case 1:
        	        // IQL.g:645:26: '0' .. '9'
        	        {
        	            MATCHRANGE('0', '9'); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleEXPONENTEx;
        	            }


        	        }
        	        break;

        	    default:
        	    
        		if ( cnt27 >= 1 )
        		{
        		    goto loop27;
        		}
        		/* mismatchedSetEx()
        		 */
        		CONSTRUCTEX();
        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        		goto ruleEXPONENTEx;
        	}
        	cnt27++;
            }
            loop27: ;	/* Jump to here if this rule does not match */
        }

    }



    // This is where rules clean up and exit
    //
    goto ruleEXPONENTEx; /* Prevent compiler warnings */
    ruleEXPONENTEx: ;

}
// $ANTLR end EXPONENT

//   Comes from: 651:2: ( 'f' | 'F' | 'd' | 'D' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start FLOAT_SUFFIX
 *
 * Looks to match the characters the constitute the token FLOAT_SUFFIX
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mFLOAT_SUFFIX(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // IQL.g:651:2: ( 'f' | 'F' | 'd' | 'D' )
    // IQL.g:
    {
        if ( LA(1) == 'D' || LA(1) == 'F' || LA(1) == 'd' || LA(1) == 'f' )
        {
            CONSUME();

        }
        else 
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleFLOAT_SUFFIXEx;
        }


    }



    // This is where rules clean up and exit
    //
    goto ruleFLOAT_SUFFIXEx; /* Prevent compiler warnings */
    ruleFLOAT_SUFFIXEx: ;

}
// $ANTLR end FLOAT_SUFFIX

//   Comes from: 655:5: ( ( '0' .. '9' )+ '.' ( '0' .. '9' )* | '.' ( '0' .. '9' )+ )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DECIMAL_LITERAL
 *
 * Looks to match the characters the constitute the token DECIMAL_LITERAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mDECIMAL_LITERAL(pIQLLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = DECIMAL_LITERAL;
       
    
    {
        //  IQL.g:655:5: ( ( '0' .. '9' )+ '.' ( '0' .. '9' )* | '.' ( '0' .. '9' )+ )
        
        ANTLR3_UINT32 alt31;

        alt31=2;

        switch ( LA(1) ) 
        {
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
        	{
        		alt31=1;
        	}
            break;
        case '.':
        	{
        		alt31=2;
        	}
            break;

        default:
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            EXCEPTION->message      = (void *)"";
            EXCEPTION->decisionNum  = 31;
            EXCEPTION->state        = 0;


            goto ruleDECIMAL_LITERALEx;
        }

        switch (alt31) 
        {
    	case 1:
    	    // IQL.g:655:9: ( '0' .. '9' )+ '.' ( '0' .. '9' )*
    	    {
    	        // IQL.g:655:9: ( '0' .. '9' )+
    	        {
    	            int cnt28=0;

    	            for (;;)
    	            {
    	                int alt28=2;
    	        	switch ( LA(1) ) 
    	        	{
    	        	case '0':
    	        	case '1':
    	        	case '2':
    	        	case '3':
    	        	case '4':
    	        	case '5':
    	        	case '6':
    	        	case '7':
    	        	case '8':
    	        	case '9':
    	        		{
    	        			alt28=1;
    	        		}
    	        	    break;

    	        	}

    	        	switch (alt28) 
    	        	{
    	        	    case 1:
    	        	        // IQL.g:655:10: '0' .. '9'
    	        	        {
    	        	            MATCHRANGE('0', '9'); 
    	        	            if  (HASEXCEPTION())
    	        	            {
    	        	                goto ruleDECIMAL_LITERALEx;
    	        	            }


    	        	        }
    	        	        break;

    	        	    default:
    	        	    
    	        		if ( cnt28 >= 1 )
    	        		{
    	        		    goto loop28;
    	        		}
    	        		/* mismatchedSetEx()
    	        		 */
    	        		CONSTRUCTEX();
    	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
    	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


    	        		goto ruleDECIMAL_LITERALEx;
    	        	}
    	        	cnt28++;
    	            }
    	            loop28: ;	/* Jump to here if this rule does not match */
    	        }
    	        MATCHC('.'); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleDECIMAL_LITERALEx;
    	        }


    	        // IQL.g:655:25: ( '0' .. '9' )*

    	        for (;;)
    	        {
    	            int alt29=2;
    	            switch ( LA(1) ) 
    	            {
    	            case '0':
    	            case '1':
    	            case '2':
    	            case '3':
    	            case '4':
    	            case '5':
    	            case '6':
    	            case '7':
    	            case '8':
    	            case '9':
    	            	{
    	            		alt29=1;
    	            	}
    	                break;

    	            }

    	            switch (alt29) 
    	            {
    	        	case 1:
    	        	    // IQL.g:655:26: '0' .. '9'
    	        	    {
    	        	        MATCHRANGE('0', '9'); 
    	        	        if  (HASEXCEPTION())
    	        	        {
    	        	            goto ruleDECIMAL_LITERALEx;
    	        	        }


    	        	    }
    	        	    break;

    	        	default:
    	        	    goto loop29;	/* break out of the loop */
    	        	    break;
    	            }
    	        }
    	        loop29: ; /* Jump out to here if this rule does not match */


    	    }
    	    break;
    	case 2:
    	    // IQL.g:656:9: '.' ( '0' .. '9' )+
    	    {
    	        MATCHC('.'); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleDECIMAL_LITERALEx;
    	        }

    	        // IQL.g:656:13: ( '0' .. '9' )+
    	        {
    	            int cnt30=0;

    	            for (;;)
    	            {
    	                int alt30=2;
    	        	switch ( LA(1) ) 
    	        	{
    	        	case '0':
    	        	case '1':
    	        	case '2':
    	        	case '3':
    	        	case '4':
    	        	case '5':
    	        	case '6':
    	        	case '7':
    	        	case '8':
    	        	case '9':
    	        		{
    	        			alt30=1;
    	        		}
    	        	    break;

    	        	}

    	        	switch (alt30) 
    	        	{
    	        	    case 1:
    	        	        // IQL.g:656:14: '0' .. '9'
    	        	        {
    	        	            MATCHRANGE('0', '9'); 
    	        	            if  (HASEXCEPTION())
    	        	            {
    	        	                goto ruleDECIMAL_LITERALEx;
    	        	            }


    	        	        }
    	        	        break;

    	        	    default:
    	        	    
    	        		if ( cnt30 >= 1 )
    	        		{
    	        		    goto loop30;
    	        		}
    	        		/* mismatchedSetEx()
    	        		 */
    	        		CONSTRUCTEX();
    	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
    	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


    	        		goto ruleDECIMAL_LITERALEx;
    	        	}
    	        	cnt30++;
    	            }
    	            loop30: ;	/* Jump to here if this rule does not match */
    	        }

    	    }
    	    break;

        }
    }
	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleDECIMAL_LITERALEx; /* Prevent compiler warnings */
    ruleDECIMAL_LITERALEx: ;

}
// $ANTLR end DECIMAL_LITERAL

/** This is the entry point in to the lexer from an object that
 *  wants to generate the next token, such as a pCOMMON_TOKEN_STREAM
 */
static void 
mTokens(pIQLLexer ctx)
{
    {
        //  IQL.g:1:8: ( T__107 | T__108 | T__109 | T__110 | T__111 | T__112 | T__113 | T__114 | T__115 | T__116 | T__117 | T__118 | T__119 | T__120 | T__121 | T__122 | T__123 | T__124 | T__125 | T__126 | T__127 | T__128 | T__129 | T__130 | T__131 | T__132 | T__133 | TK_ADD | TK_ALL | TK_ALTER | TK_AND | TK_ANY | TK_AS | TK_ASC | TK_AVG | TK_BEGIN | TK_BETWEEN | TK_BIGINT | TK_BOOLEAN | TK_BREAK | TK_BY | TK_CASE | TK_CAST | TK_CHAR | TK_COALESCE | TK_CONTINUE | TK_COUNT | TK_CREATE | TK_CROSS | TK_DATETIME | TK_DECLARE | TK_DECIMAL | TK_DESC | TK_DISTINCT | TK_DOUBLE | TK_ELSE | TK_END | TK_EXISTS | TK_FALSE | TK_FROM | TK_FULL | TK_FUNCTION | TK_GROUP | TK_HAVING | TK_IF | TK_IN | TK_INDEX | TK_INNER | TK_INTO | TK_INTEGER | TK_INTERVAL | TK_IS | TK_JOIN | TK_KEY | TK_LEFT | TK_LIKE | TK_MAX | TK_MIN | TK_NOT | TK_NULL | TK_NVARCHAR | TK_ON | TK_OR | TK_ORDER | TK_OUTER | TK_OUTPUT | TK_PRECISION | TK_PRINT | TK_PROCEDURE | TK_RAISERROR | TK_RETURN | TK_RETURNS | TK_RIGHT | TK_RLIKE | TK_SELECT | TK_SET | TK_SOME | TK_SUM | TK_SWITCH | TK_THEN | TK_TRUE | TK_UNION | TK_VARCHAR | TK_WHEN | TK_WHERE | TK_WHILE | TK_WITH | STRING_LITERAL | WSTRING_LITERAL | DOUBLE_QUOTED_STRING_LITERAL | WS | ML_COMMENT | SL_COMMENT | ID | QUOTED_ID | HEX_INTEGER_LITERAL | DECIMAL_INTEGER_LITERAL | DECIMAL_BIGINT_LITERAL | FLOATING_POINT_LITERAL | DECIMAL_LITERAL )
        
        ANTLR3_UINT32 alt32;

        alt32=120;

        alt32 = cdfa32.predict(ctx, RECOGNIZER, ISTREAM, &cdfa32);
        if  (HASEXCEPTION())
        {
            goto ruleTokensEx;
        }

        switch (alt32) 
        {
    	case 1:
    	    // IQL.g:1:10: T__107
    	    {
    	        /* 1:10: T__107 */
    	        mT__107(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 2:
    	    // IQL.g:1:17: T__108
    	    {
    	        /* 1:17: T__108 */
    	        mT__108(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 3:
    	    // IQL.g:1:24: T__109
    	    {
    	        /* 1:24: T__109 */
    	        mT__109(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 4:
    	    // IQL.g:1:31: T__110
    	    {
    	        /* 1:31: T__110 */
    	        mT__110(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 5:
    	    // IQL.g:1:38: T__111
    	    {
    	        /* 1:38: T__111 */
    	        mT__111(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 6:
    	    // IQL.g:1:45: T__112
    	    {
    	        /* 1:45: T__112 */
    	        mT__112(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 7:
    	    // IQL.g:1:52: T__113
    	    {
    	        /* 1:52: T__113 */
    	        mT__113(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 8:
    	    // IQL.g:1:59: T__114
    	    {
    	        /* 1:59: T__114 */
    	        mT__114(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 9:
    	    // IQL.g:1:66: T__115
    	    {
    	        /* 1:66: T__115 */
    	        mT__115(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 10:
    	    // IQL.g:1:73: T__116
    	    {
    	        /* 1:73: T__116 */
    	        mT__116(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 11:
    	    // IQL.g:1:80: T__117
    	    {
    	        /* 1:80: T__117 */
    	        mT__117(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 12:
    	    // IQL.g:1:87: T__118
    	    {
    	        /* 1:87: T__118 */
    	        mT__118(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 13:
    	    // IQL.g:1:94: T__119
    	    {
    	        /* 1:94: T__119 */
    	        mT__119(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 14:
    	    // IQL.g:1:101: T__120
    	    {
    	        /* 1:101: T__120 */
    	        mT__120(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 15:
    	    // IQL.g:1:108: T__121
    	    {
    	        /* 1:108: T__121 */
    	        mT__121(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 16:
    	    // IQL.g:1:115: T__122
    	    {
    	        /* 1:115: T__122 */
    	        mT__122(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 17:
    	    // IQL.g:1:122: T__123
    	    {
    	        /* 1:122: T__123 */
    	        mT__123(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 18:
    	    // IQL.g:1:129: T__124
    	    {
    	        /* 1:129: T__124 */
    	        mT__124(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 19:
    	    // IQL.g:1:136: T__125
    	    {
    	        /* 1:136: T__125 */
    	        mT__125(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 20:
    	    // IQL.g:1:143: T__126
    	    {
    	        /* 1:143: T__126 */
    	        mT__126(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 21:
    	    // IQL.g:1:150: T__127
    	    {
    	        /* 1:150: T__127 */
    	        mT__127(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 22:
    	    // IQL.g:1:157: T__128
    	    {
    	        /* 1:157: T__128 */
    	        mT__128(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 23:
    	    // IQL.g:1:164: T__129
    	    {
    	        /* 1:164: T__129 */
    	        mT__129(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 24:
    	    // IQL.g:1:171: T__130
    	    {
    	        /* 1:171: T__130 */
    	        mT__130(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 25:
    	    // IQL.g:1:178: T__131
    	    {
    	        /* 1:178: T__131 */
    	        mT__131(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 26:
    	    // IQL.g:1:185: T__132
    	    {
    	        /* 1:185: T__132 */
    	        mT__132(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 27:
    	    // IQL.g:1:192: T__133
    	    {
    	        /* 1:192: T__133 */
    	        mT__133(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 28:
    	    // IQL.g:1:199: TK_ADD
    	    {
    	        /* 1:199: TK_ADD */
    	        mTK_ADD(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 29:
    	    // IQL.g:1:206: TK_ALL
    	    {
    	        /* 1:206: TK_ALL */
    	        mTK_ALL(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 30:
    	    // IQL.g:1:213: TK_ALTER
    	    {
    	        /* 1:213: TK_ALTER */
    	        mTK_ALTER(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 31:
    	    // IQL.g:1:222: TK_AND
    	    {
    	        /* 1:222: TK_AND */
    	        mTK_AND(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 32:
    	    // IQL.g:1:229: TK_ANY
    	    {
    	        /* 1:229: TK_ANY */
    	        mTK_ANY(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 33:
    	    // IQL.g:1:236: TK_AS
    	    {
    	        /* 1:236: TK_AS */
    	        mTK_AS(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 34:
    	    // IQL.g:1:242: TK_ASC
    	    {
    	        /* 1:242: TK_ASC */
    	        mTK_ASC(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 35:
    	    // IQL.g:1:249: TK_AVG
    	    {
    	        /* 1:249: TK_AVG */
    	        mTK_AVG(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 36:
    	    // IQL.g:1:256: TK_BEGIN
    	    {
    	        /* 1:256: TK_BEGIN */
    	        mTK_BEGIN(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 37:
    	    // IQL.g:1:265: TK_BETWEEN
    	    {
    	        /* 1:265: TK_BETWEEN */
    	        mTK_BETWEEN(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 38:
    	    // IQL.g:1:276: TK_BIGINT
    	    {
    	        /* 1:276: TK_BIGINT */
    	        mTK_BIGINT(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 39:
    	    // IQL.g:1:286: TK_BOOLEAN
    	    {
    	        /* 1:286: TK_BOOLEAN */
    	        mTK_BOOLEAN(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 40:
    	    // IQL.g:1:297: TK_BREAK
    	    {
    	        /* 1:297: TK_BREAK */
    	        mTK_BREAK(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 41:
    	    // IQL.g:1:306: TK_BY
    	    {
    	        /* 1:306: TK_BY */
    	        mTK_BY(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 42:
    	    // IQL.g:1:312: TK_CASE
    	    {
    	        /* 1:312: TK_CASE */
    	        mTK_CASE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 43:
    	    // IQL.g:1:320: TK_CAST
    	    {
    	        /* 1:320: TK_CAST */
    	        mTK_CAST(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 44:
    	    // IQL.g:1:328: TK_CHAR
    	    {
    	        /* 1:328: TK_CHAR */
    	        mTK_CHAR(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 45:
    	    // IQL.g:1:336: TK_COALESCE
    	    {
    	        /* 1:336: TK_COALESCE */
    	        mTK_COALESCE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 46:
    	    // IQL.g:1:348: TK_CONTINUE
    	    {
    	        /* 1:348: TK_CONTINUE */
    	        mTK_CONTINUE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 47:
    	    // IQL.g:1:360: TK_COUNT
    	    {
    	        /* 1:360: TK_COUNT */
    	        mTK_COUNT(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 48:
    	    // IQL.g:1:369: TK_CREATE
    	    {
    	        /* 1:369: TK_CREATE */
    	        mTK_CREATE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 49:
    	    // IQL.g:1:379: TK_CROSS
    	    {
    	        /* 1:379: TK_CROSS */
    	        mTK_CROSS(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 50:
    	    // IQL.g:1:388: TK_DATETIME
    	    {
    	        /* 1:388: TK_DATETIME */
    	        mTK_DATETIME(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 51:
    	    // IQL.g:1:400: TK_DECLARE
    	    {
    	        /* 1:400: TK_DECLARE */
    	        mTK_DECLARE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 52:
    	    // IQL.g:1:411: TK_DECIMAL
    	    {
    	        /* 1:411: TK_DECIMAL */
    	        mTK_DECIMAL(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 53:
    	    // IQL.g:1:422: TK_DESC
    	    {
    	        /* 1:422: TK_DESC */
    	        mTK_DESC(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 54:
    	    // IQL.g:1:430: TK_DISTINCT
    	    {
    	        /* 1:430: TK_DISTINCT */
    	        mTK_DISTINCT(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 55:
    	    // IQL.g:1:442: TK_DOUBLE
    	    {
    	        /* 1:442: TK_DOUBLE */
    	        mTK_DOUBLE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 56:
    	    // IQL.g:1:452: TK_ELSE
    	    {
    	        /* 1:452: TK_ELSE */
    	        mTK_ELSE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 57:
    	    // IQL.g:1:460: TK_END
    	    {
    	        /* 1:460: TK_END */
    	        mTK_END(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 58:
    	    // IQL.g:1:467: TK_EXISTS
    	    {
    	        /* 1:467: TK_EXISTS */
    	        mTK_EXISTS(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 59:
    	    // IQL.g:1:477: TK_FALSE
    	    {
    	        /* 1:477: TK_FALSE */
    	        mTK_FALSE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 60:
    	    // IQL.g:1:486: TK_FROM
    	    {
    	        /* 1:486: TK_FROM */
    	        mTK_FROM(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 61:
    	    // IQL.g:1:494: TK_FULL
    	    {
    	        /* 1:494: TK_FULL */
    	        mTK_FULL(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 62:
    	    // IQL.g:1:502: TK_FUNCTION
    	    {
    	        /* 1:502: TK_FUNCTION */
    	        mTK_FUNCTION(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 63:
    	    // IQL.g:1:514: TK_GROUP
    	    {
    	        /* 1:514: TK_GROUP */
    	        mTK_GROUP(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 64:
    	    // IQL.g:1:523: TK_HAVING
    	    {
    	        /* 1:523: TK_HAVING */
    	        mTK_HAVING(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 65:
    	    // IQL.g:1:533: TK_IF
    	    {
    	        /* 1:533: TK_IF */
    	        mTK_IF(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 66:
    	    // IQL.g:1:539: TK_IN
    	    {
    	        /* 1:539: TK_IN */
    	        mTK_IN(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 67:
    	    // IQL.g:1:545: TK_INDEX
    	    {
    	        /* 1:545: TK_INDEX */
    	        mTK_INDEX(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 68:
    	    // IQL.g:1:554: TK_INNER
    	    {
    	        /* 1:554: TK_INNER */
    	        mTK_INNER(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 69:
    	    // IQL.g:1:563: TK_INTO
    	    {
    	        /* 1:563: TK_INTO */
    	        mTK_INTO(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 70:
    	    // IQL.g:1:571: TK_INTEGER
    	    {
    	        /* 1:571: TK_INTEGER */
    	        mTK_INTEGER(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 71:
    	    // IQL.g:1:582: TK_INTERVAL
    	    {
    	        /* 1:582: TK_INTERVAL */
    	        mTK_INTERVAL(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 72:
    	    // IQL.g:1:594: TK_IS
    	    {
    	        /* 1:594: TK_IS */
    	        mTK_IS(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 73:
    	    // IQL.g:1:600: TK_JOIN
    	    {
    	        /* 1:600: TK_JOIN */
    	        mTK_JOIN(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 74:
    	    // IQL.g:1:608: TK_KEY
    	    {
    	        /* 1:608: TK_KEY */
    	        mTK_KEY(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 75:
    	    // IQL.g:1:615: TK_LEFT
    	    {
    	        /* 1:615: TK_LEFT */
    	        mTK_LEFT(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 76:
    	    // IQL.g:1:623: TK_LIKE
    	    {
    	        /* 1:623: TK_LIKE */
    	        mTK_LIKE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 77:
    	    // IQL.g:1:631: TK_MAX
    	    {
    	        /* 1:631: TK_MAX */
    	        mTK_MAX(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 78:
    	    // IQL.g:1:638: TK_MIN
    	    {
    	        /* 1:638: TK_MIN */
    	        mTK_MIN(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 79:
    	    // IQL.g:1:645: TK_NOT
    	    {
    	        /* 1:645: TK_NOT */
    	        mTK_NOT(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 80:
    	    // IQL.g:1:652: TK_NULL
    	    {
    	        /* 1:652: TK_NULL */
    	        mTK_NULL(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 81:
    	    // IQL.g:1:660: TK_NVARCHAR
    	    {
    	        /* 1:660: TK_NVARCHAR */
    	        mTK_NVARCHAR(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 82:
    	    // IQL.g:1:672: TK_ON
    	    {
    	        /* 1:672: TK_ON */
    	        mTK_ON(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 83:
    	    // IQL.g:1:678: TK_OR
    	    {
    	        /* 1:678: TK_OR */
    	        mTK_OR(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 84:
    	    // IQL.g:1:684: TK_ORDER
    	    {
    	        /* 1:684: TK_ORDER */
    	        mTK_ORDER(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 85:
    	    // IQL.g:1:693: TK_OUTER
    	    {
    	        /* 1:693: TK_OUTER */
    	        mTK_OUTER(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 86:
    	    // IQL.g:1:702: TK_OUTPUT
    	    {
    	        /* 1:702: TK_OUTPUT */
    	        mTK_OUTPUT(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 87:
    	    // IQL.g:1:712: TK_PRECISION
    	    {
    	        /* 1:712: TK_PRECISION */
    	        mTK_PRECISION(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 88:
    	    // IQL.g:1:725: TK_PRINT
    	    {
    	        /* 1:725: TK_PRINT */
    	        mTK_PRINT(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 89:
    	    // IQL.g:1:734: TK_PROCEDURE
    	    {
    	        /* 1:734: TK_PROCEDURE */
    	        mTK_PROCEDURE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 90:
    	    // IQL.g:1:747: TK_RAISERROR
    	    {
    	        /* 1:747: TK_RAISERROR */
    	        mTK_RAISERROR(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 91:
    	    // IQL.g:1:760: TK_RETURN
    	    {
    	        /* 1:760: TK_RETURN */
    	        mTK_RETURN(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 92:
    	    // IQL.g:1:770: TK_RETURNS
    	    {
    	        /* 1:770: TK_RETURNS */
    	        mTK_RETURNS(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 93:
    	    // IQL.g:1:781: TK_RIGHT
    	    {
    	        /* 1:781: TK_RIGHT */
    	        mTK_RIGHT(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 94:
    	    // IQL.g:1:790: TK_RLIKE
    	    {
    	        /* 1:790: TK_RLIKE */
    	        mTK_RLIKE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 95:
    	    // IQL.g:1:799: TK_SELECT
    	    {
    	        /* 1:799: TK_SELECT */
    	        mTK_SELECT(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 96:
    	    // IQL.g:1:809: TK_SET
    	    {
    	        /* 1:809: TK_SET */
    	        mTK_SET(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 97:
    	    // IQL.g:1:816: TK_SOME
    	    {
    	        /* 1:816: TK_SOME */
    	        mTK_SOME(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 98:
    	    // IQL.g:1:824: TK_SUM
    	    {
    	        /* 1:824: TK_SUM */
    	        mTK_SUM(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 99:
    	    // IQL.g:1:831: TK_SWITCH
    	    {
    	        /* 1:831: TK_SWITCH */
    	        mTK_SWITCH(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 100:
    	    // IQL.g:1:841: TK_THEN
    	    {
    	        /* 1:841: TK_THEN */
    	        mTK_THEN(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 101:
    	    // IQL.g:1:849: TK_TRUE
    	    {
    	        /* 1:849: TK_TRUE */
    	        mTK_TRUE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 102:
    	    // IQL.g:1:857: TK_UNION
    	    {
    	        /* 1:857: TK_UNION */
    	        mTK_UNION(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 103:
    	    // IQL.g:1:866: TK_VARCHAR
    	    {
    	        /* 1:866: TK_VARCHAR */
    	        mTK_VARCHAR(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 104:
    	    // IQL.g:1:877: TK_WHEN
    	    {
    	        /* 1:877: TK_WHEN */
    	        mTK_WHEN(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 105:
    	    // IQL.g:1:885: TK_WHERE
    	    {
    	        /* 1:885: TK_WHERE */
    	        mTK_WHERE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 106:
    	    // IQL.g:1:894: TK_WHILE
    	    {
    	        /* 1:894: TK_WHILE */
    	        mTK_WHILE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 107:
    	    // IQL.g:1:903: TK_WITH
    	    {
    	        /* 1:903: TK_WITH */
    	        mTK_WITH(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 108:
    	    // IQL.g:1:911: STRING_LITERAL
    	    {
    	        /* 1:911: STRING_LITERAL */
    	        mSTRING_LITERAL(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 109:
    	    // IQL.g:1:926: WSTRING_LITERAL
    	    {
    	        /* 1:926: WSTRING_LITERAL */
    	        mWSTRING_LITERAL(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 110:
    	    // IQL.g:1:942: DOUBLE_QUOTED_STRING_LITERAL
    	    {
    	        /* 1:942: DOUBLE_QUOTED_STRING_LITERAL */
    	        mDOUBLE_QUOTED_STRING_LITERAL(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 111:
    	    // IQL.g:1:971: WS
    	    {
    	        /* 1:971: WS */
    	        mWS(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 112:
    	    // IQL.g:1:974: ML_COMMENT
    	    {
    	        /* 1:974: ML_COMMENT */
    	        mML_COMMENT(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 113:
    	    // IQL.g:1:985: SL_COMMENT
    	    {
    	        /* 1:985: SL_COMMENT */
    	        mSL_COMMENT(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 114:
    	    // IQL.g:1:996: ID
    	    {
    	        /* 1:996: ID */
    	        mID(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 115:
    	    // IQL.g:1:999: QUOTED_ID
    	    {
    	        /* 1:999: QUOTED_ID */
    	        mQUOTED_ID(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 116:
    	    // IQL.g:1:1009: HEX_INTEGER_LITERAL
    	    {
    	        /* 1:1009: HEX_INTEGER_LITERAL */
    	        mHEX_INTEGER_LITERAL(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 117:
    	    // IQL.g:1:1029: DECIMAL_INTEGER_LITERAL
    	    {
    	        /* 1:1029: DECIMAL_INTEGER_LITERAL */
    	        mDECIMAL_INTEGER_LITERAL(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 118:
    	    // IQL.g:1:1053: DECIMAL_BIGINT_LITERAL
    	    {
    	        /* 1:1053: DECIMAL_BIGINT_LITERAL */
    	        mDECIMAL_BIGINT_LITERAL(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 119:
    	    // IQL.g:1:1076: FLOATING_POINT_LITERAL
    	    {
    	        /* 1:1076: FLOATING_POINT_LITERAL */
    	        mFLOATING_POINT_LITERAL(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 120:
    	    // IQL.g:1:1099: DECIMAL_LITERAL
    	    {
    	        /* 1:1099: DECIMAL_LITERAL */
    	        mDECIMAL_LITERAL(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;

        }
    }

    
    goto ruleTokensEx; /* Prevent compiler warnings */
ruleTokensEx: ;
}

/* =========================================================================
 * Lexer matching rules end.
 * =========================================================================
 */
/* End of Lexer code
 * ================================================
 * ================================================
 */ 


/* End of code
 * =============================================================================
 */
